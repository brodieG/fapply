% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compile.R
\name{r2c-compile}
\alias{r2c-compile}
\alias{r2cf}
\alias{r2cl}
\alias{r2cq}
\title{Compile Eligible R Calls Into Native Instructions}
\usage{
r2cf(
  x,
  dir = NULL,
  check = getOption("r2c.check.result", FALSE),
  quiet = getOption("r2c.quiet", TRUE),
  clean = is.null(dir),
  optimize = getOption("r2c.optimize", TRUE),
  envir = environment(x)
)

r2cl(
  x,
  formals = NULL,
  dir = NULL,
  check = getOption("r2c.check.result", FALSE),
  quiet = getOption("r2c.quiet", TRUE),
  clean = is.null(dir),
  optimize = getOption("r2c.optimize", TRUE),
  envir = parent.frame()
)

r2cq(
  x,
  formals = NULL,
  dir = NULL,
  check = getOption("r2c.check.result", FALSE),
  quiet = getOption("r2c.quiet", TRUE),
  clean = is.null(dir),
  optimize = getOption("r2c.optimize", TRUE),
  envir = parent.frame()
)
}
\arguments{
\item{x}{an object to compile into an "r2c_fun", for \code{r2cf} an R function, for
\code{r2cq} an expression that will be captured unevaluated, for \code{r2cl} an R
expression escaped with \code{\link{quote}}.  See details.}

\item{dir}{NULL (default), or character(1L) name of a file system directory
to store the shared object file in.  If NULL a temporary directory will be
used. The shared object will also be loaded, and if \code{dir} is NULL the
directory with the file will be removed after loading.  Currently the
capability to re-use generated shared objects across R sessions is not
formally supported, but can likely be arranged for by preserving the
directory.}

\item{check}{TRUE or FALSE (default), if TRUE will evaluate the R expression
with the input data and compare that result to the one obtained from the
\code{r2c} C code evaluation, marking the result with attributes that indicate
that the result was identical, and if not, also with an attribute with the
result of an \code{all.equal} comparison.  The check is only carried out when an
\code{r2c} function is invoked directly (see example).}

\item{quiet}{whether to suppress the compilation output.}

\item{clean}{TRUE or FALSE, whether to remove the \code{dir} folder containing the
generated C code and the shared object file after the shared object is
\code{\link{dyn.load}}ed.  Normally this is an auto-generated temporary folder.  This
will only delete folders that have the same directory root as one generated
by \code{tempfile()} to avoid accidents.  If you manually provide \code{dir} you will
need to manually delete the directory yourself.}

\item{optimize}{TRUE (default) or FALSE whether to enable "compiler"
optimizations. Currently it is just the automatic re-use of repeated
computation results.  You can use \code{\link{get_r_code}} to see if optimizations
were applied.}

\item{envir}{environment to use as the enclosure of the function evaluation
environment.  It defaults to the environment from which the compilation
function is called, or for \code{r2cf} the environment of \code{fun}.  See details.}

\item{formals}{character vector of the names of the parameters for the
resulting "r2c_fun", a list of formals as generated with e.g. \code{\link{alist}}, or
NULL (default).  NULL causes all free symbols in \code{x} to become parameters
to the result "r2c_fun" in the order they appear in \code{x}'s call tree (see
details).  Non-default values can be used to specify different parameter
order, and in the list form also to specify default values for parameters.
Symbols in \code{x} not in \code{formals} will be resolved against the evaluation
environment at run time.}

\item{TRUE, }{FALSE, or an integer setting optimization levels.  Currently
applies \code{\link{reuse_calls}} if not FALSE or 0.}
}
\value{
an "r2c_fun" function; this is an unusual function so please see
details.
}
\description{
The \verb{r2c*} functions translate eligible R calls into C, compile them into
native instructions using \verb{R CMD SHLIB}, and return an interface to that
code in the form of an "r2c_fun" function.  This function will carry out
out numerical calculations with \code{r2c} native instructions instead of with the
standard R routines. "r2c_fun" functions are intended to be run with the
\code{r2c} \link{runners} for fast iterated calculations.
}
\details{
While "r2c_fun" functions can be called in the same way as normal R
functions, there is limited value in doing so.  "r2c_fun" functions are
optimized to be invoked invoked indirectly with \link{runners}.  In many common
cases it is likely that using an "r2c_fun" directly instead of with a runner
will be slower than evaluating the corresponding R expression.

Each of the \verb{r2c*} functions addresses different types of input:
\itemize{
\item \code{r2cf} generates an "r2c_fun" function from a regular R function.
\item \code{r2cq} captures an unquoted R expression and turns it into an "r2c_fun"
function (e.g. \code{r2cq(a + b)}).
\item \code{r2cl} turns quoted R language (e.g. as generated by \code{\link{quote}}) into an
"r2c_fun" function (e.g. \code{r2cl(quote(a + b))}).
}

Currently the following functions are supported in \code{x} (or in the body of \code{x}
for \code{r2cf}):
\itemize{
\item Binary operators: \code{+}, \code{-}, \code{*}, \code{/}, and \code{^}.
\item Statistics: \code{mean}, \code{sum}, \code{length}.
\item Assignment and braces: \verb{<-}, \code{=}, and \verb{\{}.
}

Calls must be in the form \code{fun(...)} (\verb{a fun b} for operators)  where \code{fun}
is the name of the function.  Functions must be bound to their original
symbols for them to be recognized.  For \code{r2c} provided functions like
\code{\link{mean1}} you may use the \code{::} form to compile expressions that contain them
without attaching the \code{{r2c}} package.  Empty braces are disallowed, and
assignments may only be done at the top level or at a brace level (see
examples).  References to external variables (i.e. not in \code{data} or
\code{MoreArgs}) that cause side effects (e.g. \link[=bindenv]{active bindings},
promises the evaluation of which cause side effects)
may cause unexpected results.  All external references are evaluated once
before any other computations are carried out.

For \code{r2cl} and \code{r2cq}, symbols used as parameters to \code{call} and its
constituent sub-calls (e.g. the \code{x} and \code{y} in \code{sum(x) + y}) will become
parameters to the output "r2c_fun" function.  There must be at least one such
symbol in \code{call}.  Parameter order follows that of appearance in the call
tree after everything is \code{\link{match.call}}ed.  Symbols beginning with \code{.R2C} are
reserved for use by \code{r2c} and thus disallowed in \code{call}.  You may also
directly set the parameter list with the \code{formals} parameter, or with \code{r2cf}.

Parameters used with "r2c_fun" supported functions are categorized into data
parameters and control parameters.  For example, in \code{sum(x, na.rm=TRUE)}, \code{x}
is considered a data parameter and \code{na.rm} a control parameter.  Control
parameters are evaluated the same as external references (see above).  All
data parameters must be attribute-less numeric vectors.  Integer vectors are
supported, but they are coerced to numeric (and thus copied) before use.  If
all data inputs are integer and the R counterpart functions in \code{call} support
integer output, the result will be returned as integer by coercing (thus
copying) the otherwise numeric result to integer.  There are no general
type restrictions on control parameters, but each implemented function will
only accept values for them that would make sense for the R counterparts.

Outside of the aforementioned constraints, \code{r2c} attempts to mimic the
corresponding R function semantics to the \code{identical} level, but there may be
corner cases that differ, particularly those involving missing or infinite
values.

Like with regular functions, unbound symbols are resolved in the lexical
environment of the function.  You can set a different environment on creation
of the function with the \code{envir} parameter, but Currently there is no way to
change it afterwards (\code{environment(r2c_fun) <- x} will likely just break the
function).

\code{r2c} may process the provided call either to apply optimizations (see
\code{optimize} parameter), or because a call needs to be modified to work
correctly with \code{r2c}.  The processing leaves call semantics unchanged.  If
\code{r2c} modified a call, \code{\link{get_r_code}} will show a "processed" member with the
modified call.

The structure of "r2c_fun" functions is subject to change without notice in
future \code{r2c} releases.  The only supported uses of them are standard
invocation with the \code{(} operator and use with \code{r2c} functions that accept
them as inputs.

\code{r2c} requires a C99 or later compatible implementation with floating point
infinity defined and the \code{R_xlen_t} range representable without precision
loss as double precision floating point.  It is unknown whether R supports C
implementations that fail this requirement, and if it does they are probably
rare.
}
\examples{
r2c_sum_sub <- r2cq(sum(x - y))
r2c_sum_sub <- r2cl(quote(sum(x - y)))  ## equivalently
sum_sub <- function(x, y) sum(x - y)
r2c_sum_sub <- r2cf(sum_sub)            ## equivalently
r2c_sum_sub(-1, c(1, 2, 3))

## Set parameter order for r2cq
r2c_sum_sub2 <- r2cq(sum(x - y), formals=c('y', 'x'))
r2c_sum_sub2(-1, c(1, 2, 3))

## Leave symbols unbound, here `y` is resolved in the lexical environment
r2c_sum_sub3 <- r2cq(sum(x - y), formals='x')
y <- 999
local({y <- -1; r2c_sum_sub3(c(1, 2, 3))})

##  Make a version that is checked
r2c_sum_check <- r2cq(sum(x), check=TRUE)
r2c_sum_check(1:10)                                 # checked

## Checks are disabled when using runners
group_exec(r2c_sum_check, 1:10, groups=rep(1L, 10)) # not checked

## Multi-line statements with assignments are supported
slope <- function(x, y) {
  mux <- mean(x)
  x_mux <- x - mux
  sum(x_mux * (y - mean(y))) / sum(x_mux^2)
}
r2c_slope <- r2cf(slope)
u <- runif(10)
v <- runif(10)
r2c_slope(u, v)

## Note `r2c` automatically optimizes re-used calls, so intermediate
## assignments may be unnecessary:
slope2 <- function(x, y)
  sum((x - mean(x)) * (y - mean(y))) / sum((x - mean(x))^2)
r2c_slope2 <- r2cf(slope2)
get_r_code(r2c_slope2)
identical(r2c_slope(u, v), r2c_slope2(u, v))

## But assignments in arguments to other calls are disallowed
slope2 <- function(x, y)
  sum((x_mux <- x - mean(x)) * (y - mean(y))) / sum(x_mux^2)
try(r2c_slope2 <- r2cf(slope2))  # Error
}
\seealso{
\code{\link{runners}} to iterate "r2c_fun" functions on varying data,
\code{\link{r2c-inspect}} for functions to retrieve meta data from the function,
including the generated C code and the compiler output.
}
