% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compile.R
\name{r2c-compile}
\alias{r2c-compile}
\alias{r2cf}
\alias{r2cl}
\alias{r2cq}
\title{Compile Eligible R Calls Into Native Instructions}
\usage{
r2cf(
  x,
  dir = NULL,
  check = getOption("r2c.check.result", FALSE),
  quiet = getOption("r2c.quiet", TRUE),
  clean = is.null(dir),
  optimize = getOption("r2c.optimize", TRUE),
  envir = environment(x)
)

r2cl(
  x,
  formals = NULL,
  dir = NULL,
  check = getOption("r2c.check.result", FALSE),
  quiet = getOption("r2c.quiet", TRUE),
  clean = is.null(dir),
  optimize = getOption("r2c.optimize", TRUE),
  envir = parent.frame()
)

r2cq(
  x,
  formals = NULL,
  dir = NULL,
  check = getOption("r2c.check.result", FALSE),
  quiet = getOption("r2c.quiet", TRUE),
  clean = is.null(dir),
  optimize = getOption("r2c.optimize", TRUE),
  envir = parent.frame()
)
}
\arguments{
\item{x}{an object to compile into an "r2c_fun", for \code{r2cf} an R function,
for \code{r2cq} an expression that will be captured unevaluated, for \code{r2cl} an R
expression escaped with \code{\link{quote}}.  See details.}

\item{dir}{NULL (default), or character(1L) name of a file system directory
to store the shared object file in.  If NULL a temporary directory will be
used. The shared object will also be loaded, and if \code{dir} is NULL the
directory with the file will be removed after loading.  Currently the
capability to re-use generated shared objects across R sessions is not
formally supported, but can likely be arranged for by preserving the
directory.}

\item{check}{TRUE or FALSE (default), if TRUE will evaluate the R expression
with the input data and compare that result to the one obtained from the
\code{r2c} C code evaluation, marking the result with attributes that indicate
that the result was identical, and if not, also with an attribute with the
result of an \code{all.equal} comparison.  The check is only carried out when an
\code{r2c} function is invoked directly (see example).}

\item{quiet}{whether to suppress the compilation output.}

\item{clean}{TRUE or FALSE, whether to remove the \code{dir} folder containing the
generated C code and the shared object file after the shared object is
\code{\link{dyn.load}}ed.  Normally this is an auto-generated temporary folder.  This
will only delete folders that have the same directory root as one generated
by \code{tempfile()} to avoid accidents.  If you manually provide \code{dir} you will
need to manually delete the directory yourself.}

\item{optimize}{TRUE (default) or FALSE whether to enable "compiler"
optimizations. Currently it is just the automatic re-use of repeated
computation results.  You can use \code{\link{get_r_code}} to see if optimizations
were applied.}

\item{envir}{environment to use as the enclosure of the function evaluation
environment.  It defaults to the environment from which the compilation
function is called, or for \code{r2cf} the environment of \code{fun}.  See details.}

\item{formals}{character vector of the names of the parameters for the
resulting "r2c_fun", a list of formals as generated with e.g. \code{\link{alist}}, or
NULL (default).  NULL causes all free symbols in \code{x} to become parameters
to the result "r2c_fun" in the order they appear in \code{x}'s call tree (see
details).  Non-default values can be used to specify different parameter
order, and in the list form also to specify default values for parameters.
Symbols in \code{x} not in \code{formals} will be resolved against the evaluation
environment at run time.}

\item{TRUE, }{FALSE, or an integer setting optimization levels.  Currently
applies \code{\link{reuse_calls}} if not FALSE or 0.}
}
\value{
an "r2c_fun" function; this is an unusual function so please see
details.
}
\description{
The \verb{r2c*} functions translate eligible R calls into C, compile them into
native instructions using \verb{R CMD SHLIB}, and return an interface to that
code in the form of an "r2c_fun" function.  This function will carry out
out numerical calculations with \code{r2c} native instructions instead of with the
standard R routines. "r2c_fun" functions are intended to be run with the
\code{r2c} \link{runners} for fast iterated calculations.  It is the intention of \code{r2c}
to adhere as closely as possible to R semantics for the subset of R that it
supports when used with numeric vectors.
}
\section{r2c Generated Functions}{


While "r2c_fun" functions can be called in the same way as normal R
functions, there is limited value in doing so.  "r2c_fun" functions are
optimized to be invoked invoked indirectly with \link{runners}.  In many common
cases it is likely that using an "r2c_fun" directly instead of with a runner
will be slower than evaluating the corresponding R expression.

The lifecycle of an \code{r2c} function has two stages.
\enumerate{
\item Compilation with \code{r2cq} or similar.
\item Execution, either direct or via \link{runners}.
a. One time memory allocation for current data / groups.
b. Iterative execution over groups.
}

The second stage involves a single allocation step, followed by as many
iterations as there are groups (or windows).  The same set of allocations is
re-used for every iteration.

Each of the \verb{r2c*} functions addresses different types of input:
\itemize{
\item \code{r2cf} generates an "r2c_fun" function from a regular R function.
\item \code{r2cq} captures an unquoted R expression and turns it into an "r2c_fun"
function (e.g. \code{r2cq(a + b)}).
\item \code{r2cl} turns quoted R language (e.g. as generated by \code{\link{quote}}) into an
"r2c_fun" function (e.g. \code{r2cl(quote(a + b))}).
}

For \code{r2cl} and \code{r2cq}, symbols used as parameters to \code{call} and its
constituent sub-calls (e.g. the \code{x} and \code{y} in \code{sum(x) + y}) will become
parameters to the output "r2c_fun" function.  There must be at least one such
symbol in \code{call}.  Parameter order follows that of appearance in the call
tree after everything is \code{\link{match.call}}ed.  Symbols beginning with \code{.R2C} are
reserved for use by \code{r2c} and thus disallowed in \code{call}.  You may also
directly set the parameter list with the \code{formals} parameter, or with \code{r2cf}.

As with regular R functions, unbound symbols (a.k.a. external references) are
resolved in the lexical environment of the function.  You can set a different
environment on creation of the function with the \code{envir} parameter, but
currently there is no way to change it afterwards (\code{environment(r2c_fun) <- x} will likely just break the function).  External references are evaluated
once at allocation time and re-used for each iteration.
}

\section{Parameter and Return Value}{


Parameters used with "r2c_fun" supported functions are categorized into data
parameters and control parameters.  For example, in \code{sum(x, na.rm=TRUE)}, \code{x}
is considered a data parameter and \code{na.rm} a control parameter.

All data parameters must be attribute-less atomic vectors.  Numeric, integer,
and logical vectors are supported, but they are coerced to numeric (double),
and thus logical and integer vectors are copied before use.  All internal
operations are carried out on double precision floating point values, and for
some functions on long doubles on architectures that supports them.  In
cases where the output type is knowable to be either integer or logical,
\code{r2c} will coerce the result to the corresponding type, again with a copy.
To avoid copies provide all inputs as doubles.

Control parameters are evaluated once at allocation time, even when they
reference symbols that are otherwise iteration varying. So in
\code{sum(x, na.rm=x)} where \code{x} is part of the iteration varying data, the second
\code{x} will be evaluated a single time as the entire \code{x} vector.  That value
will be used for \code{na.rm} for every iteration.  On the other hand, the first
\code{x} will change across iterations to that iteration's subset.  Control
parameters will not respect re-bindings that are made within an "r2c"
expression.  In \verb{x <- y; sum(x, na.rm=x)} the second \code{x} will still
reference whatever \code{x} was prior to being re-bound to \code{y}.  While the
semantic inconsistency of control parameters is unfortunate, it allows the
use of arbitrary objects for iteration constant parameters, and should not
manifest in the common use cases.  Each \code{r2c} supported function has a fixed
definition of which parameters are control parameters.  There are no general
type restrictions on control parameters, but each implemented function will
only accept values for them that would make sense for the R counterparts.
}

\section{Supported R Functions and Constraints}{


The following functions are supported in \code{x} (or in the body of \code{x} for
\code{r2cf}):
\itemize{
\item Arithmetic functions: \code{+}, \code{-}, \code{*}, \code{/}, and \code{^}.
\item Relational functions: \code{<}, \code{<=}, \code{>}, \code{>=}, \code{==}, \code{!=}.
\item Logical functions: \code{&}, \code{&&}, \code{|}, \code{||}, \code{!}, \code{ifelse}.
\item Statistics: \code{mean}, \code{sum}, \code{length}, \code{all}, \code{any}.
\item Assignment and braces: \verb{<-}, \code{=}, and \verb{\{}.
\item Branches: \verb{if/else}.
\item Sequences: \code{seq_along}.
}

In general these will behave as in R, with the following exceptions:
\itemize{
\item \code{ifelse} and \code{if} / \verb{else} always return in a common type that can support
both \code{yes} and \code{no} values.
\item \code{if}/\verb{else} returns \code{numeric(0)} instead of NULL if an empty branch is taken.
\item \code{&&} and \code{||} always evaluate all parameters.
\item \verb{\{} must contain at least one parameter (no empty braces).
\item \code{seq_along} always returns a double vector, never integer.
\item Assignments may only be nested in braces (\verb{\{}) or in control structure
branches.  This is a recursive requirement, so \code{mean(if(a) x <- y)} is
disallowed.
\item Additional constraints detailed next.
}

Calls must be in the form \code{fun(...)} (\verb{a fun b} for operators)  where \code{fun}
is the name of the function.  Functions must be bound to their original
symbols for them to be recognized.  For \code{r2c} provided functions like
\code{\link{mean1}} you may use the \code{::} form to compile expressions that contain them
without attaching the \code{{r2c}} package.  References to external variables
(i.e. not in \code{data} or \code{MoreArgs}) that cause side effects (e.g. \link[=bindenv]{active bindings}, promises the evaluation of which cause side effects)
may cause unexpected results.  All external references and control
parameter expressions (see "r2c Generated Functions") are evaluated once
before any other computations are carried out.

Control structures include \code{if} / \verb{else} statements and loops.  All of these
have branches; the loop branches are loop not taken (0 iterations) vs loop
taken (1+ iterations).  Control structures add additional constraints:
\itemize{
\item If used, control structure return values must be guaranteed to be the same
size irrespective of the branch taken.
\item If used after a control structure, assignments therein must be consistent
in size irrespective of branch taken.
}

Outside of the aforementioned constraints and exceptions, \code{r2c} attempts to
mimic the corresponding R function semantics to the \code{identical} level, but
there may be corner cases that differ, particularly those involving missing
or infinite values.
}

\section{Details}{


\code{r2c} may process the provided call either to apply optimizations (see
\code{optimize} parameter), or because a call needs to be modified to work
correctly with \code{r2c}.  The processing leaves call semantics unchanged.  If
\code{r2c} modified a call, \code{\link{get_r_code}} will show a "processed" member with the
modified call.

\code{r2c} requires a C99 or later compatible implementation with floating point
infinity defined and the \code{R_xlen_t} range representable without precision
loss as double precision floating point.  It is unknown whether R supports C
implementations that fail this requirement, and if it does they are probably
rare.

Interrupts are supported at the \link{runner} level, e.g. \emph{between} groups or
windows, each time a preset number of elements has been processed since the
last interrupt check.  There is infrastructure to support within
iteration-interrupts, but it adds overhead when dealing with many iterations
with few elements each and thus is disabled at the moment.

The structure of "r2c_fun" functions is subject to change without notice in
future \code{r2c} releases.  The only supported uses of them are standard
invocation with the \code{(} operator and use with the \link{runners}.
}

\examples{
r2c_sum_sub <- r2cq(sum(x - y))
r2c_sum_sub <- r2cl(quote(sum(x - y)))  ## equivalently
sum_sub <- function(x, y) sum(x - y)
r2c_sum_sub <- r2cf(sum_sub)            ## equivalently
r2c_sum_sub(-1, c(1, 2, 3))

## Set parameter order for r2cq
r2c_sum_sub2 <- r2cq(sum(x - y), formals=c('y', 'x'))
r2c_sum_sub2(-1, c(1, 2, 3))

## Leave symbols unbound, here `y` is resolved in the lexical environment
r2c_sum_sub3 <- r2cq(sum(x - y), formals='x')
y <- 999
local({y <- -1; r2c_sum_sub3(c(1, 2, 3))})

##  Make a version that is checked
r2c_sum_check <- r2cq(sum(x), check=TRUE)
r2c_sum_check(1:10)                                 # checked

## Checks are disabled when using runners
group_exec(r2c_sum_check, 1:10, groups=rep(1L, 10)) # not checked

## Multi-line statements with assignments are supported
slope <- function(x, y) {
  mux <- mean(x)
  x_mux <- x - mux
  sum(x_mux * (y - mean(y))) / sum(x_mux^2)
}
r2c_slope <- r2cf(slope)
u <- runif(10)
v <- runif(10)
r2c_slope(u, v)

## Note `r2c` automatically optimizes re-used calls, so intermediate
## assignments may be unnecessary:
slope2 <- function(x, y)
  sum((x - mean(x)) * (y - mean(y))) / sum((x - mean(x))^2)
r2c_slope2 <- r2cf(slope2)
get_r_code(r2c_slope2)
identical(r2c_slope(u, v), r2c_slope2(u, v))

## But assignments in arguments to other calls are disallowed
slope2 <- function(x, y)
  sum((x_mux <- x - mean(x)) * (y - mean(y))) / sum(x_mux^2)
try(r2c_slope2 <- r2cf(slope2))  # Error
}
\seealso{
\code{\link{runners}} to iterate "r2c_fun" functions on varying data,
\code{\link{r2c-inspect}} for functions to retrieve meta data from the function,
including the generated C code and the compiler output.
}
