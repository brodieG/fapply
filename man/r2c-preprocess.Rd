% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/r2c-package.R
\name{r2c-preprocess}
\alias{r2c-preprocess}
\title{Preprocessing}
\description{
\code{r2c} will preprocess R expressions to implement optimizations, or to convert
calls to a format better suited for translation to C.  Preprocessing will not
affect the semantics of an R expression, but in some cases the pre-processed
call may look quite different from the input expression.  In general \code{r2c}
attempts to conceal the preprocessed expressions, but in some cases they may
leak via error messages or other pathways.  This documentation page exists so
users that encounter such leaks can get some indication of what is happening.
\code{\link[=get_r_code]{get_r_code(..., raw=TRUE)}}  will show the fully pre-processed
version of the R code.
}
\section{Control Structures}{


Preprocessing is most impactful for control structures.  Most R level calls
are converted 1-1 into C level calls.  Control structures are more
complicated because we need to generate the call structure itself without a
direct correspondence of R call to structural element.  The
preprocessor \link[=intermediate-representation]{decomposes regular if / else calls}
calls as:

\if{html}{\out{<div class="sourceCode">}}\preformatted{if(a) x else y
}\if{html}{\out{</div>}}

Into:

\if{html}{\out{<div class="sourceCode">}}\preformatted{if_test(a)
r2c_if(if_true(x), if_false(y))
}\if{html}{\out{</div>}}

The decomposition creates a 1-1 R-C correspondence without changing the
overall semantics (although the intermediate semantics are not the same due
to the use of implicit state to decide what branch to evaluate).  You can
run these functions as R functions, but there is no reason to do so, and
further \code{r2c_if} will always return the true branch as the state from
\code{if_test} is not recorded in pure R evaluation.  There is only a loose
correspondence between the R function names and the C code they cause to be
generated as we exploit how \code{r2c} linearizes the AST to cause the pieces of
the control structure to be emitted at the right spots (i.e.  this is a hack
to get control flow to fit into an implementation that originally did not
intend to allow them).
}

\examples{
get_r_code(r2c.if <- r2cq(if(a) b else c), raw=TRUE)
r2c.if(TRUE, 1, 2)
r2c.if(FALSE, 1, 2)
get_r_code(r2c.for <- r2cq({
  res <- 0
  # This is slow, use `sum(x)` instead...
  for(i in seq_along(x)) res <- res + x[i]
  res
}), raw=TRUE)
r2c.for(1:10)
}
