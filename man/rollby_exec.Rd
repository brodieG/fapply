% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/window.R
\name{rollby_exec}
\alias{rollby_exec}
\alias{rollat_exec}
\alias{rollbw_exec}
\title{Execute r2c Function on Rolling Windows in Data}
\usage{
rollby_exec(
  fun,
  data,
  width,
  by,
  offset = width/2,
  x = seq_along(first_vec(data)),
  start = x[1L],
  end = x[length(x)],
  bounds = "[)",
  partial = TRUE,
  MoreArgs = list(),
  enclos = parent.frame()
)

rollat_exec(
  fun,
  data,
  width,
  at = x,
  offset = width/2,
  x = seq_along(first_vec(data)),
  bounds = "[)",
  partial = TRUE,
  MoreArgs = list(),
  enclos = parent.frame()
)

rollbw_exec(
  fun,
  data,
  left,
  right,
  x = seq_along(first_vec(data)),
  bounds = "[)",
  partial = TRUE,
  MoreArgs = list(),
  enclos = parent.frame()
)
}
\arguments{
\item{fun}{an "r2c_fun" function as produced by \code{\link{r2c}}, except with the
additional restriction that it must be guaranteed to produce scalar
results as used with this function.}

\item{data}{a numeric vector, or a list of equal length numeric vectors.
If a named list, the vectors will be matched to \code{fun} parameters by those
names.  Elements without names are matched positionally.  If a list must
contain at least one vector.  Conceptually, this parameter is used
similarly to \code{envir} parameter to \code{\link[base:eval]{base::eval}} when that is a list (see
\code{enclos}).}

\item{width}{scalar positive numeric giving the width of the window interval.}

\item{by}{strictly positive, finite, non-NA scalar numeric, interpreted
as the stride to increment the anchor by after each \code{fun} application.}

\item{offset}{finite, non-na, scalar numeric representing the leftward offset
of the left end of the window from its "anchor".  See "Intervals".}

\item{x}{finite, non-NA, monotonically increasing numeric vector with as many
elements as \code{data}.  Each element is the position on the real line of the
corresponding \code{data} element (see notes).}

\item{start}{non-na, finite scalar numeric position on real line of first
"anchor".  Windows that extend to the left of \code{start} (or to the right of
\code{end}) are incomplete and will compute as NA if \code{partial=FALSE} (see
\code{partial}).}

\item{end}{non-na, finite scalar numeric position on real line of last
"anchor", see \code{start}.}

\item{partial}{TRUE or FALSE (default), whether to allow computation on
partial windows that extent to the left of \code{start} and/or to the \code{right} of
\code{end}.  If \code{FALSE}, such windows will compute to NA (see \code{start}).  If
\code{TRUE} all data elements positioned within the window are eligible for
computation, even if they are outside of \verb{[start,end]} (subject to
\code{bounds}).  To exclude such points remove them from \code{data} before using
these functions.}

\item{MoreArgs}{a list of R objects to pass on as iteration-invariant
arguments to \code{fun}.  Unlike with \code{data}, each of the objects therein are
passed in full to the native code for each iteration  This is useful for
arguments that are intended to remain constant across iterations.  Matching
of these objects to \code{fun} parameters is the same as for \code{data}, with
positional matching occurring after the elements in \code{data} are matched.}

\item{enclos}{environment to use as the \code{enclos} parameter to
\code{\link[base:eval]{base::eval}} when evaluating expressions or matching calls (see \code{data}).}

\item{at}{non-NA, finite, monotonically increasing numeric vector anchor
positions on the real line for each window to be computed on (see notes).}

\item{left}{non-NA, finite, monotonically increasing numeric
positions of the left end of each window on the real line (see notes).}

\item{right}{non-NA, finite, monotonically increasing numeric
positions of the left end of each window on the real line, where
\code{right >= left} (see notes).}
}
\value{
A numeric vector of length:
\itemize{
\item \code{(end - start) \%/\% by + 1} for \code{rollby_exec}.
\item \code{length(at)} for \code{rollat_exec}.
\item \code{length(left)} for \code{rollbw_exec}.
}
}
\description{
Calls the native code associated with \code{fun} on sequential windows along the
\code{data} vector(s).  The \verb{roll*_exec} functions provide different mechanism for
defining the space covered by each window. All of them will compute \code{fun} for
each iteration with the set of data "elements" that fall within that window.
\itemize{
\item \code{rollby_exec}: equal width windows aligned relative to regularly spaced
(\code{by} apart) "anchors" positions.
\item \code{rollat_exec}: equal width windows aligned relative to "anchors" with
specific positions given in \code{at}.
\item \code{rollbw_exec}: windows with ends defined explicitly in \code{left} and \code{right}.
}
}
\note{
For the purposes of this documentation, the first value in a set or the
lowest value in a range are considered to be the "leftmost" values.
We think of vectors as starting on the "left" and ending on the "right",
and of the real line as having negative infinity to the "left" of positive
infinity.

Position vectors are expected to be monotonically increasing and devoid
of NA and non-finite values.  Additionally it is expected that \code{right >= left}.  It is the user's responsibility to ensure these expectations are
met.  Window bounds are compared to element positions sequentially using by
LT, LTE, GT, GTE relational operators in C, the exact set of which
depending on \code{bounds}.  If any of the position vectors are out of order, or
contain NAs, or non-finite values, some, or all windows may not contain the
elements they should.  Further, if there are any NAs the result may depend
on the C implementation used to compile this package.  Future versions may
check for and disallow disordered, NA, and/or non-finite values in the
position vectors.
}
\section{Data Elements}{


\code{data} is made up of "elements", where an "element" is a vector element if
\code{data} is an atomic vector, or a "row" if it is a "data.frame" / list of
equal-length atomic vectors.  Elements of \code{data} are arrayed on the real line
at positions specified by \code{x}.  The default is for each element to be located
at its integer rank, i.e. the first element is at 1, the second at 2, and so
on.  Rank position is the sole and implicit option for \code{\link{rolli_exec}}, which
will be more efficient for that case, slightly so for \code{by = 1}, and more so
for larger values of \code{by}.
}

\section{Windows}{


Windows are intervals on the real line aligned (adjustably) relative to an
"anchor" point given by \code{at} for  \code{rollat_exec}, or derived from \code{start} and
\code{by} for \code{rollby_exec}.  \code{rollbw_exec} defines the ends of each window
explicitly via \code{left} and \code{right}.  Interval bounds are closed on the left
and open on the right by default.

As an illustration for \code{rollby_exec} and \code{rollat_exec}, consider the case of
\code{width = 3} windows at the fourth iteration, with various \code{offset} values. The
offset is the distance from the left end of the window to the anchor:

\if{html}{\out{<div class="sourceCode">}}\preformatted{                   +------------- 4th iteration, anchor is 4.0
                   V
1.0   2.0   3.0   4.0   5.0   6.0   7.0 | < Real Line
 1     2     3     4     5     6     7  | < Element Rank
                   |
                   |                      Offset    In-window Elements
          [-----------------)           | o = w/2   \{3, 4, 5\}
                   [-----------------)  | o =   0   \{4, 5, 6\}
 [-----------------)                    | o =   w   \{1, 2, 3\}
}\if{html}{\out{</div>}}

In each case we get three elements in the window, although this is only
because the positions of the elements are on the integers.  Because the
windows are open on the right, elements that align exactly on the right end
of the window are excluded.  With irregularly spaced elements, e.g. with
\code{x = c(1, 1.25, 2.5, 5.3, 7, ...)}, we might see (positions approximate):

\if{html}{\out{<div class="sourceCode">}}\preformatted{                   +------------- 4th iteration, base index is 4.0
                   V
1.0   2.0   3.0   4.0   5.0   6.0   7.0 | < Real Line
 1 2      3        |       4         5  | < Element Rank
                   |
                   |                      Offset    In-window
          [-----------------)           | o = w/2   \{3, 4\}
                   [-----------------)  | o =   0   \{4\}
 [-----------------)                    | o =   w   \{1, 2, 3\}
}\if{html}{\out{</div>}}
}

\section{Equivalence}{


The \verb{roll*_exec} functions can be ordered by increasing generality:

\code{\link{rolli_exec}} < \code{rollby_exec} < \code{rollat_exec} < \code{rollbw_exec}

Each of the functions can replicate the semantics of any of the less general
functions, but with increased generality come slight efficiency decreases.

\code{rolli_exec} has semantics similar to the simple use case for
\code{zoo::rollapply}, \verb{data.table::froll*}, and \verb{RcppRoll::roll*}.
\code{rollat_exec(..., x=x, at=x)} has semantics similar to \code{slider::slide_index}.
}

\section{Performance}{


There are no special optimizations beyond the use of \code{{r2c}} functions
over regular R functions.  For wide windows there are more efficient
solutions depending on the statistic applied.  For example, for rolling means
and a few other simple statistics \code{{data.table}} offers the "on-line"
algorithm and \code{{slider}} the "segment tree" algorithm, each with different
performance and precision trade-offs.  In testing with sums we've found the
"segment tree" algorithm to start outperforming \code{{r2c}} at window size ~100.
At that size, the \code{data.table} "on-line" algorithm is significantly faster.
An advantage of \code{{r2c}} is that it remains fast for any arbitrary expression
of the supported functions, whereas the "on-line" and "segment tree"
implementations are limited to a narrow set of predefined calculations like
\code{sum}.

For \code{by} values wider than the typical difference between \code{x} values,
implementations that adjust the search stride along \code{x} taking advantage of
its ordered nature will likely be faster.  \code{\link{rolli_exec}} does this.

Any ALTREP objects generated for use in \code{x}, \code{at}, \code{left}, or \code{right}
will be expanded.  Implementing ALTREP access for them is desirable, but
would complicate the code substantially so is unlikely to get implemented.

Recall that the less general the \verb{roll*_} function is, the better performance
it will have (see "Equivalence").
}

\seealso{
\code{\link{r2c}} for more details on the behavior and constraints of
"r2c_fun" functions, \code{\link[base:eval]{base::eval}} for the semantics of \code{enclos}.

\code{\link{first_vec}}.

Other rolling functions: 
\code{\link{rolli_exec}()}
}
\concept{rolling functions}
