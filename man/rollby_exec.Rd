% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/window.R
\name{rollby_exec}
\alias{rollby_exec}
\alias{rollat_exec}
\alias{rollbw_exec}
\title{Compute on Sequential Windows on Data}
\usage{
rollby_exec(
  fun,
  data,
  width,
  by,
  offset = 0,
  position = seq(1, length(first_vec(data)), 1),
  start = position[1L],
  end = position[length(position)],
  bounds = "[)",
  MoreArgs = list(),
  enclos = parent.frame()
)

rollat_exec(
  fun,
  data,
  width,
  at = position,
  offset = 0,
  position = seq(1, length(first_vec(data)), 1),
  bounds = "[)",
  MoreArgs = list(),
  enclos = parent.frame()
)

rollbw_exec(
  fun,
  data,
  left,
  right,
  position = seq(1, length(first_vec(data)), 1),
  bounds = "[)",
  MoreArgs = list(),
  enclos = parent.frame()
)
}
\arguments{
\item{fun}{an "r2c_fun" function as produced by \code{\link{r2c}}, except with the
additional restriction that it must be guaranteed to produce scalar
results as used with this function.}

\item{data}{a numeric vector, or a list of equal length numeric
vectors.  If a named list, the vectors will be matched to \code{fun} parameters
by those names.  Elements without names are matched positionally.  If a
list must contain at least one vector.  Conceptually, this parameter is
used similarly to \code{envir} parameter to \code{\link[base:eval]{base::eval}} when that is a list
(see \code{enclos}).}

\item{width}{scalar positive numeric giving the width of the window interval.
Unlike with \code{\link{rolli_exec}}'s \code{n}, \code{width} must be scalar.}

\item{by}{strictly positive, finite, non-NA scalar numeric, interpreted
as the stride to increment the anchor by after each \code{fun} application.}

\item{offset}{finite, non-na, scalar numeric representing the offset
of the window from its "anchor".  Defaults to 0, which means the left end
of the window is aligned with the anchor (i.e. conceptually equivalent to
\code{align="left"} for \code{\link{rolli_exec}}).  Use \code{-width/2} for center aligned, and
\code{-width} for right aligned.  See "Intervals".  Note this default is
different to that for \code{\link{rolli_exec}}.}

\item{position}{finite, non-NA, monotonically increasing numeric vector with
as many elements as \code{data}.  Each element in \code{position} is the position on
the real line of the corresponding \code{data} element (see notes).  Integer
vectors are coerced to numeric.}

\item{start}{non-na, finite scalar numeric position on real line of first
"anchor".  Windows may extend to the left of \code{start} (or to the right of
\code{end}) based on \code{offset}, and will include all data elements inside the
window, even if they are outside \verb{[start,end]}.}

\item{end}{non-na, finite scalar numeric position on real line of last
"anchor", see \code{start}.}

\item{bounds}{scalar character to determine whether elements positions on
a window boundary are included or excluded from the window:
\itemize{
\item "[)": include elements on left boundary, exclude those on right (default).
\item "(]": include elements on right boundary, exclude those on left.
\item "[]": include elements on either boundary.
\item "()": exclude elements on either boundary.
}

[)": include elements on left boundary, exclude those on right (default).
\itemize{
\item "(]: R:)\%22:\%20include\%20elements\%20on\%20left\%20boundary,\%20exclude\%20those\%20on\%20right\%20(default).\%0A*\%20\%22(
}}

\item{MoreArgs}{a list of R objects to pass on as iteration-invariant
arguments to \code{fun}.  Unlike with \code{data}, each of the objects therein are
passed in full to the native code for each iteration  This is useful for
arguments that are intended to remain constant across iterations.  Matching
of these objects to \code{fun} parameters is the same as for \code{data}, with
positional matching occurring after the elements in \code{data} are matched.}

\item{enclos}{environment to use as the \code{enclos} parameter to
\code{\link[base:eval]{base::eval}} when evaluating expressions or matching calls (see \code{data}).}

\item{at}{non-NA, finite, monotonically increasing numeric vector of anchor
positions on the real line for each window (see notes).
Integer vectors are coerced to numeric.}

\item{left}{non-NA, finite, monotonically increasing numeric
positions of the left end of each window on the real line (see notes).
Integer vectors are coerced to numeric.}

\item{right}{non-NA, finite, monotonically increasing numeric
positions of the left end of each window on the real line, where
\code{right >= left} (see notes).  Integer vectors are coerced to numeric.}
}
\value{
A numeric vector of length:
\itemize{
\item \code{(end - start) \%/\% by + 1} for \code{rollby_exec}.
\item \code{length(at)} for \code{rollat_exec}.
\item \code{length(left)} for \code{rollbw_exec}.
}
}
\description{
A \link[=runners]{runner} that calls the native code associated with \code{fun} on
sequential windows along \code{data} vector(s) with "elements" positioned on the
real line.  Data element positions can be specified and irregular, so equal
sized windows may contain different number of elements.  Window positions may
be specified independent of data element positions.  Each \verb{roll*_exec}
function provides a different mechanism for defining the space covered by
each window.  All of them will compute \code{fun} for each iteration with the set
of data "elements" that fall within that window.
\itemize{
\item \code{rollby_exec}: equal width windows spaced \code{by} apart.
\item \code{rollat_exec}: equal width windows at specific positions given in \code{at}.
\item \code{rollbw_exec}: windows with ends defined explicitly in \code{left} and \code{right}.
}

Additionally, \code{\link{rolli_exec}} is available for variable integer-width windows
spaced \code{by} apart, but \code{data} elements are rank-positioned only.
}
\note{
For the purposes of this documentation, the first value in a set or the
lowest value in a range are considered to be the "leftmost" values.
We think of vectors as starting on the "left" and ending on the "right",
and of the real line as having negative infinity to the "left" of positive
infinity.

Position vectors are expected to be monotonically increasing and devoid
of NA and non-finite values.  Additionally it is expected that \code{right >= left}.  It is the user's responsibility to ensure these expectations are
met.  Window bounds are compared to element positions sequentially using by
LT, LTE, GT, GTE relational operators in C, the exact set of which
depending on \code{bounds}.  If any of the position vectors are out of order, or
contain NAs, or non-finite values, some, or all windows may not contain the
elements they should.  Further, if there are any NAs the result may depend
on the C implementation used to compile this package.  Future versions may
check for and disallow disordered, NA, and/or non-finite values in the
position vectors.
}
\section{Data Elements}{


\code{data} is made up of "elements", where an "element" is a vector element if
\code{data} is an atomic vector, or a "row" if it is a "data.frame" / list of
equal-length atomic vectors.  Elements of \code{data} are arrayed on the real line
by \code{position}.  The default is for each element to be located at its integer
rank, i.e. the first element is at 1, the second at 2, and so on.  Rank
position is the sole and implicit option for \code{\link{rolli_exec}}, which will be
more efficient for that case, slightly so for \code{by = 1}, and more so for
larger values of \code{by}.
}

\section{Windows}{


Windows are intervals on the real line aligned (adjustably) relative to an
"anchor" point given by \code{at} for  \code{rollat_exec}, or derived from \code{start} and
\code{by} for \code{rollby_exec}.  \code{rollbw_exec} defines the ends of each window
explicitly via \code{left} and \code{right}.  Interval bounds are closed on the left
and open on the right by default.

As an illustration for \code{rollby_exec} and \code{rollat_exec}, consider the case of
\code{width = 3} windows at the fourth iteration, with various \code{offset} values.
The offset is the distance from the left end of the window to the anchor:

\if{html}{\out{<div class="sourceCode">}}\preformatted{## rollby_exec(..., by=1, width=3)
                   +------------- 4th iteration, anchor is 4.0
                   V
1.0   2.0   3.0   4.0   5.0   6.0   7.0 | < Real Line
 1     2     3     4     5     6     7  | < Element Position
                   |
                   |                      Offset     In-window Elements
                   [-----------------)  |     0      \{4, 5, 6\}
          [-----------------)           |  -w/2      \{3, 4, 5\}
 [-----------------)                    |    -w      \{1, 2, 3\}
}\if{html}{\out{</div>}}

In each case we get three elements in the window, although this is only
because the positions of the elements are on the integers.  Because the
windows are open on the right, elements that align exactly on the right end
of the window are excluded.  With irregularly spaced elements, e.g. with
\code{position = c(1, 1.25, 2.5, 5.3, 7, ...)}, we might see (positions approximate):

\if{html}{\out{<div class="sourceCode">}}\preformatted{## rollby_exec(..., by=1, width=3, position=c(1, 1.25, 2.5, 5.3, 7))
                   +------------- 4th iteration, base index is 4.0
                   V
1.0   2.0   3.0   4.0   5.0   6.0   7.0 | < Real Line
 1 2      3        |       4         5  | < Element ~Position Elements
                   |
                   |                      Offset     In-window
                   [-----------------)  |     0      \{4\}
          [-----------------)           |  -w/2      \{3, 4\}
 [-----------------)                    |    -w      \{1, 2, 3\}
}\if{html}{\out{</div>}}

Unlike with \code{\link{rolli_exec}} there is no \code{partial} parameter as there is no
expectation of a fixed number of elements in any given window.

A restriction is that both ends of a window must be monotonically increasing
relative to their counterparts in the prior window.  This restriction might
be relaxed for \code{rollbw_exec} in the future, likely at the cost of
performance.
}

\section{Equivalence}{


The \verb{roll*_exec} functions can be ordered by increasing generality:

\code{\link{rolli_exec}} < \code{rollby_exec} < \code{rollat_exec} < \code{rollbw_exec}

Each of the functions can replicate the semantics of any of the less general
functions, but with increased generality come efficiency decreases (see
"Performance").  One exception is that \code{\link{rolli_exec}} supports fully variable
width windows.  \code{rollbw_exec} supports variable width windows, with the
constraint that window ends must be increase monotonically for each
iteration.

\code{rolli_exec} has semantics similar to the simple use case for
\code{zoo::rollapply}, \verb{data.table::froll*}, \verb{RcppRoll::roll*}, and
\verb{slider::slide_<fun>}.  \code{rollat_exec(..., position=x, at=x)} has semantics
similar to \code{slider::slide_index}, but is more flexible because \code{at} need not
be \code{position}.
}

\section{Performance}{


In general \code{{r2c}} should perform better than most alternate window
functions for "arbitrary" statistics (i.e. those that can be composed from
\code{{r2c}} supported functions).  Some packages implement algorithms that will
outperform \code{{r2c}} on wide windows for a small set of simple predefined
statistics.  For example, for rolling means \code{{data.table}} and \code{{roll}} offer
the "on-line" algorithm, and \code{{slider}} the "segment tree" algorithm, each
with different performance and precision trade-offs.

In testing with sums we've found the \code{{slider}} (v0.2.2) "segment tree"
algorithm to start outperforming \code{{r2c}} at window size ~100 for
\code{slider::slide_sum} and at window size ~1000 for \code{slider::slide_index_sum}.

The "on-line" algorithms are significantly faster than either \code{{r2c}} or
\code{{slider}}, and at least on systems with 80 bit long doubles the precision
loss (tested on \code{{data.table}} 1.4.16) seems tolerable for many applications.
The \code{{data.table}} "exact" algorithm in single thread mode has performance
near identical to \code{\link{rolli_exec}}.

For \code{by} values wider than the typical difference between \code{position} values,
implementations that adjust the search stride along \code{position} taking advantage of
its ordered nature will likely be faster.  \code{\link{rolli_exec}} does this.

Any ALTREP objects generated for use in \code{position}, \code{at}, \code{left}, or \code{right}
will be expanded.  Implementing ALTREP access for them is desirable, but
would complicate the code substantially so is unlikely to get implemented.

Recall that the less general the \verb{roll*_} function is, the better performance
it will have (see "Equivalence").  The differences are slight between the
by/at/bw implementations, and also for \code{rolli_exec} if \verb{by << n}.  If
\verb{by >> n}, \code{rolli_exec} can be much faster.

Testing was done on a 6th generation Skylake.
}

\examples{
## Simulate transactions occurring ~4 days
old.opt <- options(digits=3)
set.seed(1)
count <- 150
frequency <- 1/(3600 * 24 * 4)
time <- as.POSIXct('2022-01-01') - rev(cumsum(rexp(count, frequency)))
revenue <- runif(count) * 100
data.frame(time, revenue)[c(1:3,NA,seq(count-2, count)),]

r2c_mean <- r2cq(mean(x))

## Mean trailing quarter revenue, computed/reported "monthly"
month <- 3600 * 24 * 30  # more or less
by30 <- rollby_exec(
  r2c_mean, revenue, position=time, width=3 * month, by=month,
  start=as.POSIXct('2021-01-01'),
  offset=-3 * month   # trailing three months
)
by30

## Same, but explicit times via `at`; notice these are not exactly monthly
timeby30 <- seq(as.POSIXct('2021-01-01'), to=max(time), by=month)
timeby30[1:10]
at30 <- rollat_exec(
  r2c_mean, revenue, position=time, width=3 * month,
  at=timeby30, offset=-3 * month
)
at30
identical(by30, at30)

## Use exact monthly times with `at`
timebymo <- seq(as.POSIXct('2021-01-01'), to=max(time), by="+1 month")
timebymo[1:10]
atmo <- rollat_exec(
  r2c_mean, revenue, position=time, width=3 * month,
  at=timebymo, offset=-3 * month
)
(rev.90 <- data.frame(time=timebymo, prev.90=atmo))[1:5,]

## Exact intervals with `rollexec_bw`.
months <- seq(as.POSIXct('2020-10-01'), to=max(time), by="+1 month")
left <- head(months, -3)
right <- tail(months, -3)
bwmo <- rollbw_exec(r2c_mean, revenue, position=time, left=left, right=right)
(rev.qtr <- data.frame(time=right, prev.qtr=bwmo))[1:5,]

## These are not exactly the same because -90 days is not always 3 months
atmo - bwmo
## Confirm bwmo is what we think it is (recall, right bound open)
identical(bwmo[1], mean(revenue[time >= '2020-10-01' & time < '2021-01-01']))

## Compare current month to trail quarter
months2 <- seq(
  as.POSIXct('2021-01-01'), length.out=nrow(rev.qtr) + 1, by="+1 month"
)
left <- months2[-length(months2)]
right <- months2[-1]
thismo <- rollbw_exec(r2c_mean, revenue, position=time, left=left, right=right)
transform(
  rev.qtr,
  this.month=thismo,
  pct.change=round((thismo - prev.qtr)/prev.qtr * 100, 1)
)
options(old.opt)
}
\seealso{
\code{\link{r2c}} for more details on the behavior and constraints of
"r2c_fun" functions, \code{\link[base:eval]{base::eval}} for the semantics of \code{enclos},
\code{\link{first_vec}} to retrieve first atomic vector.

Other runners: 
\code{\link{group_exec}()},
\code{\link{rolli_exec}()}
}
\concept{runners}
