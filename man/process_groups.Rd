% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group.R
\name{process_groups}
\alias{process_groups}
\title{Compute Group Meta Data}
\usage{
process_groups(groups, sorted = FALSE)
}
\arguments{
\item{groups}{an integer, numeric, or factor vector.  Alternatively, a list
of equal-length such vectors, the interaction of which defines individual
groups to organize the vectors in \code{data} into.  Numeric vectors are coerced
to integer, thus copied.  Vectors of integer type, but with different
classes/attributes (other than factors) will be treated as integer vectors.
The vectors must be the same length as those in \code{data}.  NA values are
considered one group. If a list, the result of the calculation will be
returned as a "data.frame", otherwise as a named vector.  Currently only
one group vector is allowed, even when using list mode.  Support for
multiple group vectors and other types of vectors will be added in the
future.}

\item{sorted}{TRUE or FALSE (default), whether the vectors in \code{groups} are
already sorted.  If set to TRUE, no sorting will be done on the groups, nor
later on the \code{data} by \code{\link{group_exec}}. If the data is truly sorted this
produces the same results while avoiding the cost of sorting.  If the data
is not sorted groups \code{g} will produce groups corresponding to equal-value
runs it contains, which might be useful in some circumstances.}
}
\value{
an "r2c.groups" object, which is a list containing group sizes,
labels, and group count, along with other meta data such as the group
ordering vector.
}
\description{
Use by \code{\link{group_exec}} to organize group data, and made available as an
exported function for the case where multiple calculations use the same group
set and thus there is an efficiency benefit in processing it once.
}
\note{
The structure and content of the return value may change in the future.
}
\examples{
## Use same group data for different but same length data.
## (alternatively, could use two functions on same data).
g <- c(1L, 2L, 2L)
x <- runif(3)
y <- runif(3)
g.r2c <- process_groups(g, sorted=TRUE)
f <- r2cq(sum(x))
group_exec(f, x, g.r2c)
group_exec(f, y, g.r2c)
}
\seealso{
\code{\link{group_exec}}
}
