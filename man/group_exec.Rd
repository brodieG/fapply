% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group.R
\name{group_exec}
\alias{group_exec}
\title{Execute r2c Function Iteratively on Groups in Data}
\usage{
group_exec(fun, data, groups, MoreArgs = list())
}
\arguments{
\item{fun}{an "r2c_fun" function as produced by \code{\link{r2c}}.}

\item{data}{a numeric vector, or a list of equal length numeric
vectors.  If a named list, the vectors will be matched to \code{fun} parameters
by those names.  Elements without names are matched positionally.  If a
list must contain at least one vector.  Conceptually, this parameter is
used similarly to \code{envir} parameter to \code{\link[base:eval]{base::eval}} when that is a list
(see \code{enclos}).}

\item{groups}{an integer, numeric, or factor vector.  Alternatively, a list
of equal-length such vectors, the interaction of which defines individual
groups to organize the vectors in \code{data} into (multiple vectors not
implemented yet).  Numeric vectors are coerced to integer, thus copied.
Vectors of integer type, but with different classes/attributes (other than
factors) will be treated as integer vectors.  The vectors must be the
same length as those in \code{data}.  NA values are considered one group. If a
list, the result of the calculation will be returned as a "data.frame",
otherwise as a named vector.  Currently only one group vector is allowed,
even when using list mode.  Support for multiple group vectors and other
types of vectors will be added in the future.  Zero length groups are not
computed on at all (e.g. missing factor levels, zero-length group vector).}

\item{MoreArgs}{a list of R objects to pass on as iteration-invariant
arguments to \code{fun}.  Unlike with \code{data}, each of the objects therein are
passed in full to the native code for each iteration  This is useful for
arguments that are intended to remain constant across iterations.  Matching
of these objects to \code{fun} parameters is the same as for \code{data}, with
positional matching occurring after the elements in \code{data} are matched.}
}
\value{
If \code{groups} is an atomic vector, a named numeric or integer vector
with the results of executing \code{fun} on each group and the names set to the
groups.  Otherwise, a "data.frame" with the group vectors as columns and
the result of the computation as the last column.
}
\description{
A \link[=runners]{runner} that organizes \code{data} into groups as defined by \code{groups},
and executes the native code associated with \code{fun} iteratively with each
group's portion of \code{data}.
}
\examples{
r2c_mean <- r2cq(mean(x))
with(mtcars, group_exec(r2c_mean, hp, groups=cyl))

r2c_slope <- r2cq(
  sum((x - mean(x)) * (y - mean(y))) / sum((x - mean(x)) ^ 2)
)
with(mtcars, group_exec(r2c_slope, list(hp, qsec), groups=cyl))

## Parameters are generated in the order they are encountered
str(formals(r2c_slope))

## Data frame output, re-order arguments
with(
  mtcars,
  group_exec(r2c_slope, list(y=hp, x=qsec), groups=list(cyl))
)

## We can provide group=invariant parameters:
r2c_sum_add_na <- r2cq(sum(x * y, na.rm=na.rm) / sum(y))
str(formals(r2c_sum_add_na))
a <- runif(10)
a[8] <- NA
weights <- c(.1, .1, .2, .2, .4)
g <- rep(1:2, each=5)
group_exec(
  r2c_sum_add_na, a, groups=g,
  MoreArgs=list(y=weights, na.rm=TRUE)  ## use MoreArgs for group-invariant
)
group_exec(
  r2c_sum_add_na, a, groups=g,
  MoreArgs=list(y=-weights, na.rm=FALSE)
)

## Groups known to be sorted can save substantial time
n <- 1e7
x <- runif(1e7)
g <- cumsum(sample(c(TRUE, rep(FALSE, 99)), n, replace=TRUE))
identical(g, sort(g))  # sorted already!
system.time(res1 <- group_exec(r2c_mean, x, g))
system.time(res2 <- group_exec(r2c_mean, x, process_groups(g, sorted=TRUE)))
identical(res1, res2)

## We can also group by runs by lying about `sorted` status
x <- 1:8
g <- rep(rep(1:2, each=2), 2)
g
group_exec(r2c_mean, x, groups=list(g))
group_exec(r2c_mean, x, groups=process_groups(list(g), sorted=TRUE))
}
\seealso{
\code{\link{r2c}} for more details on the behavior and constraints of
"r2c_fun" functions, \code{\link[base:eval]{base::eval}} for the semantics of \code{enclos}.

Other runners: 
\code{\link{rollby_exec}()},
\code{\link{rolli_exec}()}
}
\concept{runners}
