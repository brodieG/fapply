% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/window.R
\name{window_exec}
\alias{window_exec}
\alias{window_i_exec}
\title{Execute r2c Function on Sliding Windows in Data}
\usage{
window_exec(
  fun,
  width,
  data,
  MoreArgs = list(),
  by = 1L,
  partial = FALSE,
  align = "center",
  enclos = parent.frame()
)

window_i_exec(
  fun,
  width,
  index,
  data,
  MoreArgs = list(),
  by,
  align = "center",
  start = index[1L],
  end = index[length(index)],
  interval = "[)",
  partial = TRUE,
  enclos = parent.frame()
)
}
\arguments{
\item{fun}{an "r2c_fun" function as produced by \code{\link{r2c}}, except with the
additional restriction that it must be guaranteed to produce scalar
results when accounting for the other parameters used by this function.}

\item{width}{integer (\code{window_exec}) or numeric (\code{window_i_exec})
positive, finite, non-NA scalar value interpreted as the count of elements
in a window (\code{window_exec}) or the width of the window (\code{window_i_exec}).
For the latter values at both ends of the window are considered part of the
window.}

\item{data}{a numeric vector, or a list of numeric vectors, each vector the
same length as the vector(s) in \code{groups}.  If a named list, the vectors
will be matched to \code{fun} parameters by those names.  Elements without names
are matched positionally.  If a list must contain at least one vector.
Conceptually, this parameter is used similarly to \code{envir} parameter to
\code{\link[base:eval]{base::eval}} when that is a list (see \code{enclos}).}

\item{MoreArgs}{a list of R objects to pass on as group-invariant arguments
to \code{fun}.  Unlike with \code{data}, each of the objects therein are passed in
full to the native code for each group.  This is useful for arguments that
are intended to remain constant group to group.  Matching of these objects
to \code{fun} parameters is the same as for \code{data}, with positional matching
occurring after the elements in \code{data} are matched.}

\item{by}{integer (\code{window_exec}) or numeric (\code{window_i_exec})
positive, finite, non-NA scalar value interpreted as the stride to
increment the base index after each \code{fun} application.}

\item{partial}{TRUE or FALSE (default), whether to allow computation on
partial windows. If \code{FALSE}, incomplete windows will be NA.  If \code{TRUE}
vectors passed to \code{fun} may have lengths shorter than the corresponding
window sizes when the windows are partially out of bounds at the end of the
\code{data} vectors.}

\item{align}{vector of one of "center" (default), "left", "right", or a
finite non-NA integer (\code{window_exec}) or numeric (\code{window_i_exec})
scalar representing what part of the window aligns with the base index on
the vector.  Numeric values represent the leftwards offset of the "left"
end of the window relative to the base index, where \code{0} is equivalent to
"left".  See "Details" for some subtleties about the effect of align for
\code{window_exec} vs \code{window_i_exec}.}

\item{enclos}{environment to use as the \code{enclos} parameter to
\code{\link[base:eval]{base::eval}} when evaluating expressions or matching calls (see \code{data}).}

\item{index}{a numeric vector with as many elements as \code{data}, containing
finite, non-NA, monotonically increasing values to slide the window
against.  It is the user's responsibility to ensure these requirements are
met (see notes).  Data entries that correspond to index values within a
window will be used in the calculation associated with that window.
Windows are closed at their beginning and open at their end.}

\item{start}{numeric(1) first base index for windows for \code{window_i_exec}.
The range defined by \code{start} and \code{end} should intersect with values in
\code{index} otherwise you will compute on a series of empty windows.  See
"Details".}

\item{end}{numeric(1) last base index for windows for \code{window_i_exec}.  See
\code{start}.}
}
\value{
a numeric vector, the length of which is determined by the length of
the data and the value of \code{by} (\code{window_exec}), or by
\code{floor(end - start) / by + 1} (\code{window_i_exec}).
}
\description{
Calls the native code associated with \code{fun} on sequential windows along the
\code{data} vector(s).  The windows are aligned relative to a base index that
is iterated over the data range.
}
\details{
\code{data} is made up of "elements", where an "element" is a vector element if
\code{data} is an atomic vector, or a "row" if it is a "data.frame" / list of
equal length atomic vectors.  Elements of \code{data} are arrayed on the real line
in positions determined by \code{i}.  The default is for each element to be
located at its integer rank, i.e. the first element is at 1, the second at 2,
and so on.  Windows are intervals on the real line centered on each base
index, with bounds closed on the left and open on the right.  Both the bounds
types and window alignment are adjustable.

As an illustration consider the case of width 3 windows (\code{w = 3}) at the
fourth iteration, with various offset (\code{o} settings).  The offset is how far
to the left of the base index the left end of the window is aligned:

\if{html}{\out{<div class="sourceCode">}}\preformatted{                   +------------- 4th iteration, base index is 4.0
                   V
1.0   2.0   3.0   4.0   5.0   6.0   7.0 | < Real Line
 1     2     3     4     5     6     7  | < Element Rank

                                          Offset    In-window
          [-----------------)           | o = w/2   \{3, 4, 5\}
                   [-----------------)  | o =   0   \{4, 5, 6\}
 [-----------------)                    | o =   w   \{1, 2, 3\}
}\if{html}{\out{</div>}}

In each case we get three elements in the window, although this is only
because the positions of the elements are on the integers.  Because the
windows are open on the right, elements that align exactly on the right end
of the window are excluded.  With irregularly spaced elements, e.g. with \code{i = c(1, 1.25, 2.5, 5.3, 7, ...)}, we might see (positions approximate):

\if{html}{\out{<div class="sourceCode">}}\preformatted{                   +------------- 4th iteration, base index is 4.0
                   V
1.0   2.0   3.0   4.0   5.0   6.0   7.0 | < Real Line
 1 2      3                4         5  | < Element Rank

                                          Offset    In-window
          [-----------------)           | o = w/2   \{3, 4\}
                   [-----------------)  | o =   0   \{4\}
 [-----------------)                    | o =   w   \{1, 2, 3\}
}\if{html}{\out{</div>}}

The range within which values are eligible for inclusion in any window is
given by \code{start} and \code{end}.  Windows that extend outside of this range are
considered incomplete.  Setting \code{partial=FALSE} will skip calculations of
those windows and use NA for their result.

There are no special optimizations beyond the use of \code{{r2c}} functions
over regular R functions.  For wide windows there are more efficient
solutions depending on the statistic applied.  For example, for rolling means
and a few other simple statistics \code{{data.table}} offers the "on-line"
algorithm and \code{{slider}} the "segment tree" algorithm, each with different
performance and precision trade-offs.

The semantics of these function are \strong{loosely} modelled on those of
\code{zoo::rollapply}, with additional modifications inspired by
\code{slider::slide_index}.
}
\note{
For the purposes of this documentation, the first value in a set or the
lowest value in a range are considered to be the "leftmost" values.
We think of vectors as starting on the "left" and ending on the "right",
and of the real line as having negative infinity to the "left" of positive
infinity.

Window widths, alignments, and strides must be scalars (this may change
in the future).

The \code{window_i_exec} algorithm iterates over the values in the \code{index}
vector until they come in range of the window as determined by LT and LTE
relational operators in C.  As such, out of order or NA indices may cause
values to end up in a window they do not belong to, or values to be
excluded from windows they belong to.  The exact behavior of NAs with
respect to relational operators in C is not strictly defined, so the
results of \code{index} vectors containing NAs might vary depending on the C
implementation used to compile this package.  Future versions may check for
and disallow disordered or NA values in \code{index}.
}
\examples{
r2c_mean <- r2cq(mean(x))
with(
  mtcars,
  window_exec(r2c_mean, hp, width=5)
)
r2c_len <- r2cq(length(x))

window_exec(r2c_len, rep(1, 5), width=5, align='left', partial=TRUE)
window_exec(r2c_len, rep(1, 5), width=5, align='center', partial=TRUE)
window_exec(r2c_len, rep(1, 5), width=5, align='right', partial=TRUE)

index <- seq(0, 1, length.out=100) ^ (1/3)
window_i_exec(r2c_len, width=.2, by=.2, index=index, data=numeric(100))
}
\seealso{
\code{\link{r2c}} for more details on the behavior and constraints of
"r2c_fun" functions, \code{\link[base:eval]{base::eval}} for the semantics of \code{enclos}.
}
