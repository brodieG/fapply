% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/window.R
\name{window_exec}
\alias{window_exec}
\alias{window_i_exec}
\title{Execute r2c Function on Sliding Windows in Data}
\usage{
window_exec(
  fun,
  width,
  data,
  MoreArgs = list(),
  by = 1L,
  partial = FALSE,
  align = "center",
  enclos = parent.frame()
)

window_i_exec(
  fun,
  width,
  index,
  data,
  MoreArgs = list(),
  by = 1L,
  align = "center",
  start = index[1L],
  end = index[length(index)],
  enclos = parent.frame()
)
}
\arguments{
\item{fun}{an "r2c_fun" function as produced by \code{\link{r2c}}, except with the
additional restriction that it must be guaranteed to produce scalar
results when accounting for the other parameters used by this function.}

\item{width}{integer (\code{window_exec}) or numeric (\code{window_i_exec})
positive, finite, non-NA scalar value interpreted as the count of elements
in a window (\code{window_exec}) or the width of the window (\code{window_i_exec}).
For the latter values at both ends of the window are considered part of the
window.}

\item{data}{a numeric vector, or a list of numeric vectors, each vector the
same length as the vector(s) in \code{groups}.  If a named list, the vectors
will be matched to \code{fun} parameters by those names.  Elements without names
are matched positionally.  If a list must contain at least one element.
Conceptually, this parameter is used similarly to \code{envir} parameter to
\code{\link[base:eval]{base::eval}} when that is a list (see \code{enclos}).}

\item{MoreArgs}{a list of R objects to pass on as group-invariant arguments
to \code{fun}.  Unlike with \code{data}, each of the objects therein are passed in
full to the native code for each group.  This is useful for arguments that
are intended to remain constant group to group.  Matching of these objects
to \code{fun} parameters is the same as for \code{data}, with positional matching
occurring after the elements in \code{data} are matched.}

\item{by}{integer (\code{window_exec}) or numeric (\code{window_i_exec})
positive, finite, non-NA scalar value interpreted as the stride to
increment the base index after each \code{fun} application.}

\item{partial}{TRUE or FALSE (default), whether to allow computation on
partial windows. If \code{FALSE}, incomplete windows will be NA.  If \code{TRUE}
vectors passed to \code{fun} may have lengths shorter than the corresponding
window sizes when the windows are partially out of bounds at the end of the
\code{data} vectors.}

\item{align}{vector of one of "center" (default), "left", "right", or a
positive finite non-NA integer (\code{window_exec}) or numeric (\code{window_i_exec})
scalar value representing what part of the window aligns with the base
index on the vector, where "left" is the part of the window nearest the
first element of the vector.  Numeric values represent the left-wards
offset of the "left" end of the window relative to the base index, where
\code{0} is equivalent to "left".  See "Details" for some subtleties about the
effect of align for \code{window_exec} vs \code{window_i_exec}.}

\item{enclos}{environment to use as the \code{enclos} parameter to
\code{\link[base:eval]{base::eval}} when evaluating expressions or matching calls (see \code{data}).}

\item{index}{a numeric vector of finite, non-NA, monotonically increasing
values to slide the window against.  It is the user's responsibility to
ensure these requirements are met (see notes).  Data entries that
correspond to index values within a window will be used in the calculation
associated with that window.}

\item{start}{numeric(1) first base index for windows for \code{window_i_exec}.
The range defined by \code{start} and \code{end} should intersect with values in
\code{index} otherwise you will compute on a series of empty windows.  See
"Details".}

\item{end}{numeric(1) last base index for windows for \code{window_i_exec}.  See
\code{start}.}
}
\value{
a numeric vector, the length of which is determined by the length of
the data and the value of \code{by} (\code{window_exec}), or by
\code{(end - start) / by + 1} (\code{window_i_exec}).
}
\description{
Calls the native code associated with \code{fun} on sequential windows along the
\code{data} vectors.  The windows are aligned relative to a base index that is
stepped through the data range using a stride specified with \code{by}.
}
\details{
For \code{window_exec} windows are always sized \code{width} elements except in the
cases where the window overflows the beginning or end of the data and
\code{partial=TRUE}.  The first base index corresponds to the first element in the
data.  The \code{align} parameter can be used to change how the window is shifted
from the base index.  A visual illustration of the effect of the \code{align}
parameter on the fourth iteration of function application, with \code{by=1L} and
\code{width=4L}:

\if{html}{\out{<div class="sourceCode">}}\preformatted{## window_exec(..., width=4L)

       +--------- On the 4th iteration, base index is [4]
       v
 1 2 3 4 5 6 7    seq_along(x)  # `x` represents a vector in `data`
       + - - +    align = "left"
       + - - +    align = 0L
 + - - +          align = "right"
 + - - +          align = 3L
     + - - +      align = "center"
     + - - +      align = 1L
   + - - +        align = 2L
}\if{html}{\out{</div>}}

If \code{align = "left"}, on the 4th iteration elements \verb{[4:7]} will be in the
window, which is also true with \code{align = 0L}.  If \code{align = "center"} (or
\code{align = 1L}), then elements \verb{[3:6]} will be in the window.

For \code{window_i_exec} the ends of the window are always \code{width} apart, but  the
number of elements included in any given window is a function of how many of
the values in \code{index} fall between the beginning and the end of each window
(inclusive).  It is thus possible to end up with empty windows depending on
the spacing of values in \code{index}.  The initial base index defaults to the
first value in \code{index}, but can be changed with \code{start}.  Similarly, the last
base index defaults to the last value in \code{index}, but can be changed with
\code{end}.

Because \code{window_exec} windows are defined in terms of a count of elements,
but in \code{window_i_exec} they are defined in terms of position along the real
line, the meaning of numeric \code{align} values is different for each.  In
particular, for \code{window_exec}, \code{align="right"} is equivalent to
\code{align=width - 1L}, whereas for \code{window_i_exec} it is equivalent to
\code{align=width}.

The semantics of these function are \strong{loosely} modelled on those of
\code{zoo::rollapply}, with additional modifications based on
\code{slider::slide_index}.

There are no special optimizations beyond the use of \code{{r2c}} functions
over regular R functions.  For wide windows there are more efficient
solutions depending on the statistic applied.  For example, for rolling means
and a few other simple statistics \code{{data.table}} offers the "on-line"
algorithm and \code{{slider}} the "segment tree" algorithm, each with different
performance and precision trade-offs.
}
\note{
Window widths, alignments, and strides must be scalars (this may change
in the future).

The \code{window_i_exec} algorithm iterates over the values in the \code{index}
vector until they come in range of the window as determined by LT and LTE
relational operators in C.  As such, out of order or NA indices may cause
values to end up in a window they do not belong to, or values to be
excluded from windows they belong to.  The exact behavior of NAs with
respect to relational operators in C is not strictly defined, so the
results of \code{index} vectors containing NAs might vary depending on the C
implementation used to compile this package.
}
\examples{
r2c_mean <- r2cq(mean(x))
with(
  mtcars,
  window_exec(r2c_mean, hp, width=5)
)
r2c_len <- r2cq(length(x))

window_exec(r2c_len, rep(1, 5), width=5, align='left', partial=TRUE)
window_exec(r2c_len, rep(1, 5), width=5, align='center', partial=TRUE)
window_exec(r2c_len, rep(1, 5), width=5, align='right', partial=TRUE)

index <- seq(0, 1, length.out=100) ^ (1/3)
window_i_exec(r2c_len, width=.2, by=.2, index=index, data=numeric(100))
}
\seealso{
\code{\link{r2c}} for more details on the behavior and constraints of
"r2c_fun" functions, \code{\link[base:eval]{base::eval}} for the semantics of \code{enclos}.
}
