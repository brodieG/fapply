## Copyright (C) Brodie Gaslam
##
## This file is part of "r2c - Fast Iterated Statistic Computation in R"
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 or 3 of the License.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## Go to <https://www.r-project.org/Licenses> for copies of the licenses.

#' Fast Iterated Statistic Computation in R
#'
#' Compiles a subset of R into machine code so that expressions composed with
#' that subset can be applied repeatedly on varying data without interpreter
#' overhead.  Use [the compilation functions][r2c-compile] to compile R, and
#' [runners] to execute the resulting compiled code iteratively on varying data.
#'
#' @docType package
#' @name r2c-package
#' @aliases r2c
#' @import vetr
#' @importFrom utils globalVariables tail head
#' @useDynLib r2c, .registration=TRUE, .fixes="R2C_"

NULL

utils::globalVariables(".")  # for vetr .

#' Runner Functions
#'
#' @description
#'
#' "r2c_fun" functions generated by [`r2c`] can be invoked iteratively on
#' varying data with runner functions.  There are currently two types of
#' iteration available:
#'
#' * Group iteration with [`group_exec`].
#' * Rolling window iteration with [`rolli_exec`] and the other
#'   [`roll*_exec`][rollbw_exec] functions.
#'
#' @name runners
#' @family runner functions

NULL

#' Memory Use
#'
#' `r2c` [runners] examine the "r2c_fun" function to run along with provided
#' data to compute how much memory is required to support is execution.  The
#' allocations are sized to support the largest iteration in the iteration
#' varying data.  Each iteration re-uses these same allocations (or a portion
#' thereof), thereby reducing peak memory usage and fragmentation.
#'
#' Most of the `r2c` supported functions are such that the size of the result
#' can be inferred from the size of the inputs.  As such, once we know potential
#' iteration data sizes, we can recursively pre-compute how much memory we need
#' for each iteration result along with all the intermediate computations.
#'
#' There are two implications from this approach:
#'
#' 1. Result size of each subcomputation must depend only on the sizes of the
#'    inputs, not their values (with some very specific exceptions).
#' 2. The size of each subcomputation is a function of group size.
#'
#' The first implication creates the requirement that control structures like
#' `if`/`else` return results or set variables to the same size in each branch
#' (see [compile][r2c-compile]).  This is because we do not evaluate the
#' condition expression until after we've made the memory allocations.
#'
#' The second implication follows from expressions like `a + b` which depend on
#' the size of both `a` and `b`, either of which could be iteration varying
#' data, or derived from iteration varying data.  Suppose `a` is iteration
#' varying, and `b` is constant size.  What is the size of `a + b`?  It depends
#' on both the size of `b` and the size of each iteration.  If we take `i` to be
#' the iteration data size, we could express the result size as
#' `max(i, length(b))` (ignoring the possibility of 0 size inputs).  But what
#' about the size of e.g. `c(a + b, a)`?  As expressions get more complex,
#' the expressions required to represent result sizes as a function of
#' iteration size can (but doesn't have to) get more complex.  `r2c` caps the
#' level of complexity of such size expressions and will error at run time if
#' this limit is exceeded.  It should be difficult to reach this cap when
#' computing statistics.
#'
#' `r2c` carves out a small exception for expression like `numeric(x)` the size
#' of which depends on the value of the input.  These expression are allowed so
#' long as the **value** of the input in question is iteration-invariant.
#' Iteration invariant data include that passed via the `MoreArgs` parameters to
#' the [runners], or via external expressions.  See "Expression Types" in the
#' [compilation][r2c-compile] documentation.
#'
#' @name r2c-memory

NULL

#' Preprocessing
#'
#' `r2c` will preprocess R expressions to implement optimizations, or to convert
#' calls to a format better suited for translation to C.  Preprocessing will not
#' affect the semantics of an R expression, but in some cases the pre-processed
#' call may look quite different from the input expression.  In general `r2c`
#' attempts to conceal the preprocessed expressions, but in some cases they may
#' leak via error messages or other pathways.  This documentation page exists so
#' users that encounter such leaks can get some indication of what is happening.
#' [`get_r_code(..., raw=TRUE)`][get_r_code]  will show the fully pre-processed
#' version of the R code.
#'
#' @section Control Structures:
#'
#' Preprocessing is most impactful for control structures.  Most R level calls
#' are converted 1-1 into C level calls.  Control structures are more
#' complicated because we need to generate the call structure itself without a
#' direct correspondence of R call to structural element.  The
#' preprocessor [decomposes regular if / else calls][control-counterpart]
#' calls as:
#'
#' ```
#' if(a) x else y
#' ```
#' Into:
#' ```
#' if_test(a)
#' r2c_if(if_true(x), if_false(y))
#' ```
#'
#' The decomposition creates a 1-1 R-C correspondence without changing the
#' overall semantics (although the intermediate semantics are not the same due
#' to the use of implicit state to decide what branch to evaluate).  You can
#' run these functions as R functions, but there is no reason to do so, and
#' further `r2c_if` will always return the true branch as the state from
#' `if_test` is not recorded in pure R evaluation.  There is only a loose
#' correspondence between the R function names and the C code they cause to be
#' generated as we exploit how `r2c` linearizes the AST to cause the pieces of
#' the control structure to be emitted at the right spots (i.e.  this is a hack
#' to get control flow to fit into an implementation that originally did not
#' intend to allow them).
#'
#' @name r2c-preprocess
#' @examples
#' get_r_code(r2c.if <- r2cq(if(a) b else c), raw=TRUE)
#' r2c.if(TRUE, 1, 2)
#' r2c.if(FALSE, 1, 2)
#' get_r_code(r2c.for <- r2cq({
#'   res <- 0
#'   # This is slow, use `sum(x)` instead...
#'   for(i in seq_along(x)) res <- res + x[i]
#'   res
#' }), raw=TRUE)
#' r2c.for(1:10)

NULL
