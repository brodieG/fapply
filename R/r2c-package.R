## Copyright (C) Brodie Gaslam
##
## This file is part of "r2c - Fast Iterated Statistic Computation in R"
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 or 3 of the License.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## Go to <https://www.r-project.org/Licenses> for copies of the licenses.

#' Fast Iterated Statistic Computation in R
#'
#' Compiles a subset of R into machine code so that expressions composed with
#' that subset can be applied repeatedly on varying data without interpreter
#' overhead.
#'
#' For a quick start:
#'
#' * Review [supported functions][r2c-supported-funs].
#' * Use [the compilation functions][r2c-compile] to compile R.
#' * [Run][runners] your `r2c` functions iteratively on varying data.
#'
#' Details:
#'
#' * [Performance considerations][r2c-performance].
#' * [Memory use][r2c-memory].
#' * [Preprocessing][r2c-preprocess].
#' * Experimental support for [control structures][r2c-control-structures].
#' * Iteration [Constant and varying expressions][r2c-expression-types].
#'
#' @docType package
#' @name r2c-package
#' @aliases r2c
#' @import vetr
#' @importFrom utils globalVariables tail head
#' @useDynLib r2c, .registration=TRUE, .fixes="R2C_"

NULL

utils::globalVariables(".")  # for vetr .

#' Runner Functions
#'
#' @description
#'
#' "r2c_fun" functions generated by [`r2c`] can be invoked iteratively on
#' varying data with runner functions.  There are currently two types of
#' iteration available:
#'
#' * Group iteration with [`group_exec`].
#' * Rolling window iteration with [`rolli_exec`] and the other
#'   [`roll*_exec`][rollbw_exec] functions.
#'
#' @keywords internal
#' @name runners
#' @family runner functions
#' @seealso [Package Overview][r2c].

NULL

#' Supported Functions
#'
#' `r2c` supports a subset of R functions.  These functions are re-implemented
#' and optimized for iterated execution while hewing as closely as practicable
#' to the original R semantics.
#'
#' The following functions are supported by the `r2c` [compiler][r2c-compile],
#' with semantic differences to their R counterparts noted.  Parameters that
#' require [constant expressions][r2c-expression-types] are marked as such.
#'
#' * Arithmetic: `+`, `-`, `*`, `/`, and `^`.
#' * Relational: `<`, `<=`, `>`, `>=`, `==`, `!=`.
#' * Logical: `&`, `&&`, `|`, `||`, `!`, `ifelse`.
#'   * `&&` and `||` always evaluate all parameters.
#'   * `ifelse` return in a type that can support both `yes` and `no` values.
#' * Statistics: `mean`, `sum`, `length`, `all`, `any`.
#'   * `na.rm` is a [constant][r2c-expression-types] parameter.
#'   * `trim` is unsupported.
#' * Sequences: `seq_along`, `seq_len`, `rep`.
#'   * `length.out`, `times`, and `each` are
#'     [constant][r2c-expression-types] parameters.
#'   * `rep` does not take any `...` parameters.
#' * Concatenation: `c`.
#'   * Ignores/drops names.
#' * Subsetting: `x[i]`, `x[s] <- expr`.
#'   * In 1 dimension with strictly positive numeric indices.
#'   * Return value of assignment form may not be used.
#' * Initialization: `numeric` (and the r2c implemented [`numeric_along`]).
#'   * `length` is a [constant parameter][r2c-expression-types].
#' * Braces: `{`.
#' * Assignment: `<-`, `=`.
#'   * Assignments cannot be made as part of an argument (e.g.
#'     `mean(x <- y)`), except as arguments to top-level braces or braces that
#'     are part of control structure  branches.
#' * Control Structures (experimental): `if/else`, `for`.
#'   * See [Control Structures][r2c-control-structures] for important
#'     constraints and semantic differences to R.
#'
#' Expressions provided to [varying][r2c-expression-types] parameters
#' must be attribute-less numeric, integer, or logical vectors.  Integer or
#' logical inputs or outputs attract a [performance penalty][r2c-performance].
#' Parameters marked as constant may only be given constant expressions.
#'
#' Calls must be in the form `fun(...)` (`a fun b` for operators)  where `fun`
#' is the name of the function, optionally in `pkg::fun` format.  Functions must
#' be bound to their original symbols for them to be recognized.
#'
#' @keywords internal
#' @seealso [Package Overview][r2c].
#' @name r2c-supported-funs

NULL

#' Memory Use
#'
#' `r2c` [runners] pre-allocate the memory required to compute every
#' sub-expression for the single largest iteration they will execute.  This
#' same allocation is re-used for every iteration, thereby reducing peak
#' memory requirements and memory fragmentation.
#'
#' `r2c` [runners] examine "r2c_fun" functions in conjunction with the iteration
#' size of their `data` argument to compute memory requirements.  Most of
#' the [r2c supported functions][r2c-supported-funs] are such that the size of
#' the result can be inferred from the size of the inputs.  Once a
#' [runner][runners] knows the iteration data sizes, it can pre-compute how much
#' memory is needed for every sub-expression in each iteration.
#'
#' In order to expand the range of supported functions outside of those that
#' derive output size from input size, `r2c` introduces some constraints on
#' semantics.  For example, control structures like `if`/`else` are allowed so
#' long as their return values and/or any variables set in their branches are
#' the same size irrespective of the branch taken.  Functions like `numeric(x)`
#' that derive their size from the value of an input can be supported, but that
#' value must be [constant across iterations][r2c-expression-types].
#'
#' Even when output size is derivable from input size alone, there is the
#' potential for unbounded complexity.  For example, the size of `a + b` depends
#' on the size of both `a` and `b`, either of which could be
#' [iteration varying][r2c-expression-types].  As expressions get more complex,
#' e.g. `c(a + b, a)`, computing result sizes can also get more complex.  `r2c`
#' caps the level of complexity of size calculations it will support, and will
#' error at run time if this limit is exceeded.  It should be difficult to reach
#' this cap when computing statistics.
#'
#' @seealso [Package Overview][r2c].
#' @keywords internal
#' @name r2c-memory

NULL

#' Control Structures
#'
#' `r2c` supports `if` / `else` statements and `for` loops on an experimental
#' basis.  These substantially complicate the internals of `r2c`, and the
#' [performance of loops][r2c-performance] is wanting.  Continued support for
#' control structures is not guaranteed in future versions of `r2c`.
#'
#' Both `if` / `else` and `for` loops have branches; the loop branches are loop
#' not taken (0 iterations) vs loop taken (1+ iterations).  Branches add
#' constraints and semantic differences to the equivalents in R:
#'
#' * Control structure return values must be guaranteed to be the same
#'   size irrespective of the branch taken, if they are subsequently used.
#'   Return values are coerced to a common type.
#' * Assignments made within control structure branches must be guaranteed to be
#'   the same size irrespective of branch taken, if the corresponding bindings
#'   are subsequently used.  Assigned values are coerced to a common type.
#' * Control structures can be nested at most 999 levels.
#' * [Constant expressions][r2c-expression-types] must be valid in every branch.
#'
#' To clarify the last point, consider:
#'
#' ```
#' if(n > 0) sum(seq_len(n)) else 0
#' ```
#'
#' The `n` argument to `seq_len` is treated as a
#' [constant][r2c-expression-types] so it is checked at allocation time.
#' Because `r2c` does not evaluate `n > 0` at allocation time, `r2c` runs
#' `seq_len`'s validity checks for `n` even if `n` is negative.  Checks like the
#' `n > 0` above need to be done outside of `r2c`.
#'
#' There are also other minor semantic differences:
#'
#' * `if`/`else` and `for` both return `numeric(0)` instead of NULL when in R
#'   they  would return NULL.
#' * [`for`][base::for] sets `var` to NA_real_ if `length(seq) == 0` instead of
#'   NULL.
#'
#' See the [memory help page][r2c-memory] for background on the equal size
#' requirements.
#'
#' @keywords internal
#' @seealso [Package Overview][r2c].
#' @name r2c-control-structures

NULL

#' Iteration Varying and Constant Expressions
#'
#' `r2c` [runners] will vary which parts of their `data` argument are computed
#' on across iterations, so references to values from `data` are known as
#' iteration varying (varying).  Expressions that depend directly or indirectly
#' on such references are also known as varying, and those that do not are
#' known as constant.  Some `r2c` [implemented function][r2c-supported-funs]
#' parameters will only accept constant expressions.
#'
#' `r2c` uses constant parameters to allow for semantics otherwise precluded by
#' its [pre-allocated memory][r2c-memory] design.  Normally, `r2c` requires that
#' the size of the output of an expression be derivable from the **size** of its
#' inputs alone, as is the case with e.g.  `seq_along(x)`.  But many useful
#' functions require knowing the value of their inputs to compute output size,
#' e.g.  `seq_len(x)`.  `r2c` can implement functions like the latter when the
#' input value is constant because such values can be computed in R before any
#' runner iterations are executed (see examples).
#'
#' Constant expressions passed to constant parameters are evaluated once at
#' allocation time and cached.  In addition to re-use of the cached value across
#' iterations, these values are also re-used if the same expression appears for
#' a different constant parameter.  Due to the caching, constant expressions
#' that cause side-effects, use `eval`, manipulate frames, or engage in other
#' complex "meta" operations may have different effects than intended.  Constant
#' expressions passed to constant parameters may evaluate to any R object,
#' subject to the restrictions on the `r2c` function parameter they are matched
#' to.
#'
#' Every expression provided to a constant parameter must be constant, but
#' varying parameters will accept otherwise constant expressions if they abide
#' by the general `r2c` constraints on parameter values.  For simplicity of
#' implementation, constant expressions used with varying parameters are treated
#' as varying, thus not cached.  This may change in the future.
#'
#' @family r2c-topics
#' @keywords internal
#' @name r2c-expression-types
#' @examples
#' ## Constant parameter `times` takes expression `max(y)` as argument
#' f <- r2cq(rep(x, times=max(y)))
#' g <- factor(c('a','b', 'b'))
#' ## When `y` is constant, so is `max(y)` and this works
#' group_exec(f, data=list(x=1:3), groups=g, MoreArgs=list(y=2:4))
#' ## But if we make `y` varying, it does not
#' try(group_exec(f, data=list(x=1:3, y=2:4), groups=g))

NULL

#' Preprocessing
#'
#' `r2c` will preprocess R expressions to implement optimizations, or to convert
#' calls to a format better suited for translation to C.  Preprocessing will not
#' affect the semantics of an R expression, but in some cases the pre-processed
#' call may look quite different from the input expression.  In general `r2c`
#' attempts to conceal the preprocessed expressions, but in some cases they may
#' leak via error messages or other pathways.  This documentation page exists so
#' users that encounter such leaks can get some indication of what is happening.
#' [`get_r_code(..., raw=TRUE)`][get_r_code]  will show the fully pre-processed
#' version of the R code.
#'
#' @section Control Structures:
#'
#' Preprocessing is most impactful for control structures.  Most R level calls
#' are converted 1-1 into C level calls.  Control structures are more
#' complicated because we need to generate the call structure itself without a
#' direct correspondence of R call to structural element.  The
#' preprocessor [decomposes regular if / else calls][intermediate-representation]
#' calls as:
#'
#' ```
#' if(a) x else y
#' ```
#' Into:
#' ```
#' if_test(a)
#' r2c_if(if_true(x), if_false(y))
#' ```
#'
#' The decomposition creates a 1-1 R-C correspondence without changing the
#' overall semantics (although the intermediate semantics are not the same due
#' to the use of implicit state to decide what branch to evaluate).  You can
#' run these functions as R functions, but there is no reason to do so, and
#' further `r2c_if` will always return the true branch as the state from
#' `if_test` is not recorded in pure R evaluation.  There is only a loose
#' correspondence between the R function names and the C code they cause to be
#' generated as we exploit how `r2c` linearizes the AST to cause the pieces of
#' the control structure to be emitted at the right spots (i.e.  this is a hack
#' to get control flow to fit into an implementation that originally did not
#' intend to allow them).
#'
#' @seealso [Package Overview][r2c].
#' @keywords internal
#' @name r2c-preprocess
#' @examples
#' get_r_code(r2c.if <- r2cq(if(a) b else c), raw=TRUE)
#' r2c.if(TRUE, 1, 2)
#' r2c.if(FALSE, 1, 2)
#' get_r_code(r2c.for <- r2cq({
#'   res <- 0
#'   # This is slow, use `sum(x)` instead...
#'   for(i in seq_along(x)) res <- res + x[i]
#'   res
#' }), raw=TRUE)
#' r2c.for(1:10)

NULL

#' Performance Considerations
#'
#' `r2c`'s primary optimization is to remove interpreter overhead for
#' iterated calculations with varying data.  `r2c` is most beneficial for
#' calculations that would otherwise require R level calls on each of many small
#' vectors.  Additionally, `r2c` reduces [peak memory usage][r2c-memory] and
#' fragmentation.  In exchange, `r2c` adds compilation overhead that will need
#' to be amortized across [runner][runners] executions, as well as a few
#' millisecond [runner][runners] startup cost for memory allocation.
#'
#' R interpreter overhead remains noticeable into vector sizes of
#' hundreds of elements, but even with larger elements `r2c` should retain some
#' performance advantage over equivalent R code.  The more complex the R
#' expression the larger the advantage `r2c` should have.
#'
#' Like R, `r2c` is optimized for internally vectorized operations.  While you
#' can write explicit loops with `for`, they will be significantly slower than a
#' pure C version, and only marginally faster than byte compiled R equivalents.
#' This is particularly true for tight loops with arithmetic on scalar
#' variables.
#'
#' When iterating across data sub-groups, `r2c` first sorts the data by group so
#' that it can then scan through the groups sequentially.  The sorting is fast
#' thanks to the radix sort contributed to R by `data.table`, but it still adds
#' overhead.  If you re-use the same data with different `r2c` functions, you
#' should pre-sort it and use [`process_groups`].  If you know your
#' data is already sorted by group you can also use [`process_groups`] to
#' communicate that to the runners.
#'
#' `r2c` computes on floating point numeric values.  Nominally it supports
#' integer and logical values as well, but these are coerced to numeric first,
#' and thus copied.  If integer or logical inputs would cause an R expression to
#' return in those types, `r2c` coerces the final result of the corresponding
#' `r2c` expression to those types too, again with a copy.  In the future
#' coercion of results made be optional.  For best performance use only floating
#' point numeric inputs.
#'
#' Currently `r2c` implements some simple "compiler" optimizations, such as
#' [re-using][reuse_calls] results of repeated sub-expressions, and identifying
#' expired symbols (to free associated memory for re-use).  These are
#' implemented in the [preprocessing step][r2c-preproces].
#'
#' @seealso [Package Overview][r2c].
#' @keywords internal
#' @name r2c-performance

NULL
