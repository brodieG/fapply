## Copyright (C) Brodie Gaslam
##
## This file is part of "r2c - Fast Iterated Statistic Computation in R"
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 or 3 of the License.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## Go to <https://www.r-project.org/Licenses> for copies of the licenses.

#' Fast Iterated Statistic Computation in R
#'
#' Compiles a subset of R into machine code so that expressions composed with
#' that subset can be applied repeatedly on varying data without interpreter
#' overhead.  Use [the compilation functions][r2c-compile] to compile R, and
#' [runners] to execute the resulting compiled code iteratively on varying data.
#'
#' @docType package
#' @name r2c-package
#' @aliases r2c
#' @import vetr
#' @importFrom utils globalVariables tail head
#' @useDynLib r2c, .registration=TRUE, .fixes="R2C_"

NULL

utils::globalVariables(".")  # for vetr .

#' Runner Functions
#'
#' @description
#'
#' "r2c_fun" functions generated by [`r2c`] can be invoked iteratively on
#' varying data with runner functions.  There are currently two types of
#' iteration available:
#'
#' * Group iteration with [`group_exec`].
#' * Rolling window iteration with [`rolli_exec`] and the other
#'   [`roll*_exec`][rollbw_exec] functions.
#'
#' @name runners
#' @family runner functions

NULL

#' Memory Use
#'
#' `r2c` [runners] pre-allocate the memory required to compute every
#' sub-expression for the single largest iteration they will execute.  This
#' same allocation is re-used for the every iteration, thereby reducing peak
#' memory requirements and memory fragmentation.
#'
#' `r2c` [runners] examine "r2c_fun" functions in conjunction with the iteration
#' size of their `data` argument to compute memory allocation sizes.  Most of
#' the [r2c supported functions][r2c-supported-funs] are such that the size of
#' the result can be inferred from the size of the inputs.  Once a [runner]
#' knows the iteration data sizes, it can pre-compute how much memory is needed
#' for every sub-expression in each iteration.
#'
#' In order to expand the range of supported functions outside of those that
#' derive output size from input size, `r2c` introduces some constraints on
#' semantics.  For example, control structures like `if`/`else` are allowed so
#' long as their return values and/or any set variables are the same size
#' irrespective of the branch taken.  Functions like `numeric(x)` that derive
#' their size from the value of an input can be supported, but that value must
#' be [iteration invariant][r2c-expression-types].
#'
#' Even for the case functions for which output size is computable from the
#' input alone, there is complexity.  For example, the size of `a + b` depends
#' on the size of both `a` and `b`, either of which could be
#' [iteration-varying].  As expressions get more complex, e.g. `c(a + b, a)`,
#' computing result sizes can also get more complex.  `r2c` caps the level of
#' complexity of size calculations it will support, and will error at run time
#' if this limit is exceeded.  It should be difficult to reach this cap when
#' computing statistics.
#'
#' @name r2c-memory

NULL

#' Supported Functions
#'
#' `r2c` supports a subset of R functions.  These functions are re-implemented
#' and optimized for iterated execution, with the general objective of
#' reproducing R semantics as closely as practicable.
#'
#' The following functions are supported by the `r2c` [compiler][r2c-compile],
#' with semantic differences to their R counterparts noted.  Parameters are
#' [iteration-varying][r2c-expression-types] unless explicitly marked as
#' constant.
#'
#' * Arithmetic functions: `+`, `-`, `*`, `/`, and `^`.
#' * Relational functions: `<`, `<=`, `>`, `>=`, `==`, `!=`.
#' * Logical functions: `&`, `&&`, `|`, `||`, `!`, `ifelse`.
#'   * `&&` and `||` always evaluate all parameters.
#'   * `ifelse` return in a type that can support both `yes` and `no` values.
#' * Statistics: `mean`, `sum`, `length`, `all`, `any`.
#'   * `na.rm` is a [constant parameter][r2c-expression-types].
#'   * `trim` is unsupported.
#' * Sequences: `seq_along`, `seq_len`, `rep`.
#'   * `length.out`, `times`, and `each` are
#'     [constant parameter][r2c-expression-types].
#'   * `rep` does not take any `...` parameters.
#' * Concatenation: `c`.
#'   * Ignores names given to arguments.
#' * Subsetting: `[`, `x[s] <- expr`.
#'   * In 1 dimension with numeric strictly positive indices.
#'   * Return value of assignment form may not be used.
#' * Initialization: `numeric`, `numeric_along`.
#'   * `length` is a [constant parameter][r2c-expression-types].
#' * Assignment: `<-`, `=`
#'   * Disallowed nested as arguments (e.g. `mean(x <- y)`), with
#'     the exception of braces (`{`) and control structure branches.
#' * Braces: `{`.
#' * Control Structures (experimental): `if/else`, `for`.
#'   * See "Control Structures" below for important considerations.
#'
#' @section General Constraints:
#'
#' Values given to iteration-varying parameters
#' [Iteration-varying][r2c-expression-types] inputs to `r2c` supported functions
#' must be attribute less numeric, integer, or logical vectors.  Integer or
#' logical inputs or outputs attract a [performance penalty][r2c-performance].
#'
#' Calls must be in the form `fun(...)` (`a fun b` for operators)  where `fun`
#' is the name of the function, optionally in `pkg::fun` format.  Functions must
#' be bound to their original symbols for them to be recognized.
#'
#' @section Control Structures:
#'
#' `r2c` supports `if` / `else` statements and `for` loops on an experimental
#' basis.  These substantially complicate the internals of `r2c` and as such
#' might be removed in the future.
#'
#' Both `if` / `else` and `for` loops have branches; the loop branches are loop
#' not taken (0 iterations) vs loop taken (1+ iterations).  Branches add
#' constraints not present in R:
#'
#' * Control structure return values must be guaranteed to be the same
#'   size irrespective of the branch taken, if they are subsequently used.
#'   Return values are coerced to a common type.
#' * Assignments made within control structure branches must be guaranteed to be
#'   the same size irrespective of branch taken, if the corresponding bindings
#'   are subsequently used.
#' * Control structures can be nested at most 999 levels.
#'
#' There are also minor semantic differences:
#'
#' * `if`/`else` and `for` both return `numeric(0)` instead of NULL when in R
#'   they  would return NULL.
#' * [`for`][base::for] sets `var` to NA_real_ if `length(seq) == 0` instead of
#'   NULL.
#'
#' See the [memory help page][r2c-memory] for background on the equal size
#' requirements, [preprocessing][r2c-preprocess] for implementation details.
#'
#' @name r2c-supported-funs

NULL

#' Iteration Varying and Constant Expressions
#'
#' `r2c` [runners] will vary which parts of their `data` argument are computed
#' on across iterations, so references to values from `data` are known as
#' iteration varying (varying).  Expressions that depend directly or indirectly
#' on such references are also known as varying, and those that do not are
#' known as constant.  Some `r2c` [implemented function][r2c-supported-funs]
#' parameters are restricted to accepting constant expressions.
#'
#' `r2c` designates some parameters as constant so that it can implement
#' functions otherwise preclude by its [pre-allocated memory][r2c-memory]
#' design.  Normally, `r2c` requires that the size of the output
#' of an expression be derivable from the **size** of its inputs alone, as is
#' the case with e.g.  `seq_along(x)`.  But many useful functions require
#' knowing the value of their inputs to compute output size, e.g.  `seq_len(x)`.
#' `r2c` can implement functions like the latter when the input value is
#' constant because such values can be computed in R before any runner
#' iterations are executed (see examples).
#'
#' Constant expressions are evaluated once at allocation time and cached.
#' Constant expressions that appear multiple times within a single iteration
#' will re-use the cached value after the first computation.  This value will
#' also be re-used across iterations.  Due to the caching, constant expressions
#' that cause side-effects, use `eval`, manipulate frames, or engage in other
#' complex "meta" operations may have different effects than intended.  Constant
#' expressions may evaluate to any R object, subject to the restrictions on the
#' parameter they are matched to.
#'
#' Every expression provided to a constant parameter must be constant, but
#' varying parameters may accept constant expressions provided they evaluate to
#' attribute-less numeric, integer, or logical vectors (there are [performance
#' implications]a[r2c-performance] to non-numeric values).
#'
#' @name r2c-expression-types
#' @examples
#' ## Constant parameter `times` takes expression `max(y)` as argument
#' f <- r2cq(rep(x, times=max(y)))
#' g <- factor(c('a','b', 'b'))
#' ## When `y` is constant, so is `max(y)` and this works
#' group_exec(f, data=list(x=1:3), groups=g, MoreArgs=list(y=2:4))
#' ## But if we make `y` varying, it does not
#' try(group_exec(f, data=list(x=1:3, y=2:4), groups=g))

NULL

#' Preprocessing
#'
#' `r2c` will preprocess R expressions to implement optimizations, or to convert
#' calls to a format better suited for translation to C.  Preprocessing will not
#' affect the semantics of an R expression, but in some cases the pre-processed
#' call may look quite different from the input expression.  In general `r2c`
#' attempts to conceal the preprocessed expressions, but in some cases they may
#' leak via error messages or other pathways.  This documentation page exists so
#' users that encounter such leaks can get some indication of what is happening.
#' [`get_r_code(..., raw=TRUE)`][get_r_code]  will show the fully pre-processed
#' version of the R code.
#'
#' @section Control Structures:
#'
#' Preprocessing is most impactful for control structures.  Most R level calls
#' are converted 1-1 into C level calls.  Control structures are more
#' complicated because we need to generate the call structure itself without a
#' direct correspondence of R call to structural element.  The
#' preprocessor [decomposes regular if / else calls][intermediate-representation]
#' calls as:
#'
#' ```
#' if(a) x else y
#' ```
#' Into:
#' ```
#' if_test(a)
#' r2c_if(if_true(x), if_false(y))
#' ```
#'
#' The decomposition creates a 1-1 R-C correspondence without changing the
#' overall semantics (although the intermediate semantics are not the same due
#' to the use of implicit state to decide what branch to evaluate).  You can
#' run these functions as R functions, but there is no reason to do so, and
#' further `r2c_if` will always return the true branch as the state from
#' `if_test` is not recorded in pure R evaluation.  There is only a loose
#' correspondence between the R function names and the C code they cause to be
#' generated as we exploit how `r2c` linearizes the AST to cause the pieces of
#' the control structure to be emitted at the right spots (i.e.  this is a hack
#' to get control flow to fit into an implementation that originally did not
#' intend to allow them).
#'
#' @name r2c-preprocess
#' @examples
#' get_r_code(r2c.if <- r2cq(if(a) b else c), raw=TRUE)
#' r2c.if(TRUE, 1, 2)
#' r2c.if(FALSE, 1, 2)
#' get_r_code(r2c.for <- r2cq({
#'   res <- 0
#'   # This is slow, use `sum(x)` instead...
#'   for(i in seq_along(x)) res <- res + x[i]
#'   res
#' }), raw=TRUE)
#' r2c.for(1:10)

NULL

#' Performance Considerations
#'
#' Like R, `r2c` is optimized for vectorized operations.  While you can write
#' explicit loops with `for`, they will be slower than a pure C version, and
#' only marginally faster than byte compiled R equivalents.  Avoid `for` loops
#' unless you cannot express your calculation in an internally vectorized form
#' (see examples).
#'
#' @name r2c-performance

NULL
