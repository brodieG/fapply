## Copyright (C) Brodie Gaslam
##
## This file is part of "r2c - Fast Iterated Statistic Computation in R"
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 or 3 of the License.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## Go to <https://www.r-project.org/Licenses> for copies of the licenses.

#' @include code-assign-braces.R
#' @include code-ifelse.R
#' @include code-loop.R
#' @include code-summary.R
#' @include code-seq.R
#' @include code-bin.R
#' @include code-pow.R
#' @include code-logical.R
#' @include code-unary.R
#' @include code-subset.R
#' @include code-numeric.R

NULL

is.valid_arglen <- function(type)
  is.character(type[[2L]]) &&
  length(type[[2L]]) == 1L &&
  !is.na(type[[2L]]) &&
  (length(type) <= 2L || is.function(type[[3L]]))

is.valid_n_arglen <- function(type)
  length(type) >= 2L && is.character(type[[2L]]) && !anyNA(type[[2L]])

# should rationalize these...
is.valid_vecrec <- function(type)
  is.valid_n_arglen(type) && type[[1L]] == "vecrec"

is.valid_eqlen <- function(type)
  is.valid_n_arglen(type) && type[[1L]] == "eqlen"

is.valid_extern <- function(type)
  is.valid_n_arglen(type) && type[[1L]] == "extern" &&
  length(type[[2L]]) == 1L

is.valid_concat <- function(type)
  is.valid_n_arglen(type) && type[[1L]] == "concat"

is.valid_prod <- function(type)
  is.valid_n_arglen(type) && type[[1L]] == "prod"

is.valid_constant <- function(type)
  typeof(type[[2L]]) == "double" &&
  length(type[[2L]]) == 1L &&
  !is.na(type[[2L]]) &&
  type[[2L]] >= 0L

# Initialize External Parameter List (see `cgen`).
#
# @param type one of "num" or "any", where "num" represents parameters that are
#   expected to evalauate to naked numeric, and "any" those that can evalaute to
#   anything.
# @param validate a function that takes one parameter that should return TRUE or
#   a text string describing why the parameter is not valid.

ext_par <- function(type="num", validate=function(x) TRUE) {
  vetr(
    character(1L) && . %in% c("num", "any"),
    is.function(.) && length(formals(.)) == 1L
  )
  structure(list(type=PAR.EXT[type], validate=validate), class='ext_par')
}
## Validation functions for external parameters.

# mean uses isTRUE(na.rm).  Sum not sure, mabye !isFALSE(na.rm)
valid_narm <- function(na.rm) vet(LGL.1, na.rm)
valid_trim <- function(trim) {
  if(!isTRUE(trim.test <- vet(NULL || identical(., 0), trim)))
    paste0(
      c("`trim` must be set to default value (", trim.test, ")"),
      collapse="\n"
    )
  else TRUE
}
valid_length <- function(length) vet(NUM.1.POS, length)

#' Initializer for Function Registration Entries
#'
#' @section Code Generation:
#'
#' Code generation is handled by the function provided in `code.gen` which are
#' run during preprocessing.  The function should return a list with three
#' character vectors, each representing:
#'
#' * Name of the C function.
#' * Call to use to invoke the function.
#' * Definition of the C function.
#'
#' The call is generated with `code_res`, but the actual function definition
#' needs to be manually written to match the call generated by `code_res`.
#' `code_gen_summary` is a good one to look at for inspiration.
#'
#' Default parameters that every C function should have are in `ARGS.NM.BASE`,
#' and include:
#'
#' * data: an array of pointers to double, which includes every every allocation
#'   that exists at any point in time in the process, including those required
#'   to support the inputs and the output of the C function, as well as those
#'   produced by evaluation of iteration invariant numeric external expressions.
#' * lens: an array of `R_xlen_t` values, each one representing how many items
#'   the corresponding array of doubles in `data` has.
#' * di: an array of integers that represents, in order, the indices of the data
#'   parameters (i.e. internal or external numeric) of the function, in `data`.
#'   So for example, `data[di[0]]` returns a pointer to the data backing the
#'   first data parameter for the function.  If a function takes `n` args, then
#'   `data[di[n]]` points to where the result of the function should be written
#'   to.
#'
#' Additionally functions with non-numeric external parameters should include:
#'
#' * ctrl: a list of arbitrary iteration invariant objects.  In the future the
#'   hope is to add facilities to convert these into numeric so they can just
#'   live in the data array.
#'
#' Generally the C counterpart of an r2c function with `n` internal arguments is
#' supposed to compute on the data in `data[di[0:(n-1)]]` and record the result
#' into `data[di[n]]` and the length of the result into `lens[di[n]]` (although
#' the latter in theory should be known ahead of time - we use this to check
#' size calcs correct).
#'
#' For functions with variable arguments (e.g. because they have `...` in their
#' signature), be sure to include `F.ARGS.VAR` in the definition, and to use
#' `narg=TRUE` for `code_res` (see "code-summary.R" which handles both the case
#' with a single parameter, and many parameters).
#'
#' @noRd
#' @param name character(1L) symbol that will reference the function
#' @param fun the function we're trying to emulate
#' @param defn NULL if fun is a closure, otherwise a function template to use
#'   for [`match.call`]'s `definition` parameter.  Also can be NULL for
#'   primitives that only do positional matching.
#' @param extern named list, with each member corresponding to an external
#'   parameter of the same name.  The members are generated with `ext_par`.
#'   `r2c` function parameters that don't match any of the members registered
#'   here are considered "internal" (see `?"r2c-compile"`).
#' @param type list(2:3) containing the length-type of function with at position
#'   one a scalar character in "constant", "arglen", "vecrec", "eqlen",
#'   "concat", "product", or "extern", and additional meta data at position two
#'   or three that can be depending on the value in position one (see size.R for
#'   details):
#'
#'   * constant: a positive non-NA integer indicating the constant result size
#'     (e.g. 1L for `mean`)
#'   * arglen: character(1L) the name of the argument to use the length of as
#'     the result size (e.g. `probs` for [`quantile`]), also allows specifying a
#'     function at position 3 to e.g. pick which of multiple arguments matching
#'     `...` to use for the length.
#'   * vecrec, eqlen, concat, product, external: character(n) (or integer(n))
#'     the names (or indices in the matched call) of the arguments to use to
#'     compute result size.
#'
#' @param code.gen a function that generates the C code corresponding to an R
#'   function during the preprocessing steps.  Accepts as parameters:
#'
#'   * Name of the R function.
#'   * A list of the unevaluated expressions provided as parameters.
#'   * A character vector with the types of each of the unevaluated parameters,
#'     where the types are from PAR.INT and PAR.EXT.
#'
#'   The second and third argument are currently only used to detect whether we
#'   should generate the single or multi-arg versions of e.g. `sum`.  For most
#'   functions the name of the functions alone wholly determines what the C
#'   function and calls to it look like.  Almost all of the handling of
#'   internal/external parameters is done at the allocation step.
#'
#' @param in.type.validate a function to validate input types.  Will be given a
#'   named character vector with the values the possible types (e.g. "double",
#'   "logical") and the names the parameter names they were matched to.
#'   It's possible to have duplicate names with "...".
#' @param res.type one of "double", "integer", "logical", "preserve.int",
#'   "preserve.last", or "preserve".  "preserve" will cause all output to be
#'   "logical" if all inputs are "logical", "integer" if there is a mix of
#'   "logical" and "integer" (including all "integer"), and "double" if any
#'   doubles are present.  "preserve.int" is like "preserve", except the only
#'   possible output types are "integer" and "double".  "preserve.last" is like
#'   "preserve" except it only considers the last input (e.g. as for braces).
#'   "preserve.which" is like "preserve", but applies to the parameters
#'   designated by `res.type.which`.
#' @param res.type.which for use when `res.type == "preserve.which"`.
#' @param primitive.nomatch TRUE or FALSE whether the function is a primitive
#'   that doesn't match its parameters like `-`.
#'
#' @return a list containing the above information after validating it.

cgen <- function(
  name, fun=get(name, baseenv(), mode="function"),
  defn=if(typeof(fun) == 'closure') fun,
  extern=list(), type, code.gen,
  in.type.validate=function(types) TRUE,
  transform=identity,
  res.type="double", res.type.which=1L, primitive.nomatch=FALSE
) {
  vetr(
    name=CHR.1,
    fun=is.function(.),
    defn=(typeof(.) == "closure"),
    extern=list(),
    type=list() && length(.) %in% 1:3,
    code.gen=is.function(.),
    in.type.validate=is.function(.),
    transform=is.function(.),
    res.type=CHR.1 &&
      . %in% c(
        'logical', 'double', 'preserve.int', 'preserve',
        'preserve.last', 'preserve.which'
      ),
    res.type.which=INT.POS.STR,
    primitive.nomatch=LGL.1
  )
  # Limitation in vetr prevents following checks from being done above
  if(
    anyDuplicated(names(extern)) ||
    !all(vapply(extern, inherits, TRUE, "ext_par"))
  )
    stop("Internal Error: badly specified external parameter names.")

  # Check-reorder external formal params
  if(length(extern)) {
    formals <- if(typeof(defn) == 'closure') formals(defn) else formals(closure)
    if(
      (!all(names(extern) %in% names(formals)) || "..." %in% names(extern))
    )
      stop("Internal Error: external params missing from defn or include '...'.")
    extern <- extern[order(match(names(extern), names(formals)))]
  }

  stopifnot(
    is.character(type[[1L]]) && length(type[[1L]]) == 1L && !is.na(type[[1L]]),
    type[[1L]] %in%
      c("constant", "arglen", "vecrec", "eqlen", "extern", "concat", "prod"),
    (
      (type[[1L]] == "constant" && is.valid_constant(type)) ||
      (type[[1L]] == "arglen" && is.valid_arglen(type)) ||
      (type[[1L]] == "vecrec" && is.valid_vecrec(type)) ||
      (type[[1L]] == "eqlen" && is.valid_eqlen(type)) ||
      (type[[1L]] == "extern" && is.valid_extern(type)) ||
      (type[[1L]] == "concat" && is.valid_concat(type)) ||
      (type[[1L]] == "prod" && is.valid_prod(type))
    ),
    # positional matching or match.call?
    type[[1L]] %in% c("constant") ||
    (
      type[[1L]] %in%
        c('arglen', 'vecrec', 'eqlen', 'extern', 'prod', 'concat')
      # used to support integer here for positional matching, but now we force
      # names everywhere (see match_call_rec).
    )
  )
  list(
    name=name, fun=fun, defn=defn, extern=extern,
    type=type, code.gen=code.gen,
    transform=transform, res.type=res.type, res.type.which=res.type.which,
    in.type.validate=in.type.validate, primitive.nomatch=primitive.nomatch
  )
}
BIN.DEFN <- function(e1, e2) NULL
## Specialized for binops
cgen_bin <- function(name, res.type="preserve.int") {
  cgen(
    name, defn=BIN.DEFN,
    type=list("vecrec", c("e1", "e2")), code.gen=code_gen_bin,
    res.type=res.type, transform=unary_transform, primitive.nomatch=TRUE
  )
}
## Specialized for binops that require inclusion of macros (logicals)
cgen_bin2 <- function(name, res.type="preserve.int") {
  cgen(
    name, defn=BIN.DEFN,
    type=list("vecrec", c("e1", "e2")), code.gen=code_gen_bin2,
    res.type=res.type, primitive.nomatch=TRUE
  )
}

# Make sure "(" is not added to this list as it's pre-processed away.
VALID_FUNS <- c(
  # - Base Stats ---------------------------------------------------------------
  list(
    cgen(
      "sum", defn=function(..., na.rm=FALSE) NULL,
      extern=list(na.rm=ext_par("num", valid_narm)),
      type=list("constant", 1),
      code.gen=code_gen_summary,
      res.type='preserve.int'
    ),
    cgen(
      "mean", defn=base::mean.default,
      extern=list(
        na.rm=ext_par("num", valid_narm),
        trim=ext_par("any", valid_trim)
      ),
      type=list("constant", 1),
      code.gen=code_gen_summary
    ),
    cgen(
      "length", defn=function(x) NULL, type=list("constant", 1),
      code.gen=code_gen_length
    ),
    cgen(
      "all", defn=function(..., na.rm=FALSE) NULL,
      extern=list(na.rm=ext_par("num", valid_narm)),
      type=list("constant", 1),
      code.gen=code_gen_summary,
      res.type='logical'
    ),
    cgen(
      "any", defn=function(..., na.rm=FALSE) NULL,
      extern=list(na.rm=ext_par("num", valid_narm)),
      type=list("constant", 1),
      code.gen=code_gen_summary,
      res.type='logical'
    )
  ),
  # - Vec Binops ---------------------------------------------------------------

  lapply(c("+", "-", "*", "/"), cgen_bin),
  list(
    cgen(
       # needs transform, could be folded into cgen_bin like e.g. uminus
       "^", defn=BIN.DEFN,
       type=list("vecrec", c("e1", "e2")), code.gen=code_gen_pow,
       transform=pow_transform
  ) ),
  lapply(c(">", ">=", "<", "<=", "==", "!="), cgen_bin2, res.type="logical"),
  lapply(c("|", "&"), cgen_bin2, res.type='logical'),
  ## # Not implemented for now given not just a simple counterpart, but
  ## # could add a function like square to deal with it..  See myfmod in
  ## src/arithmetic.c in R sources
  ## cgen(
  ##   "%%", base::`%%`, defn=BIN.DEFN,
  ##   type=list("vecrec", c("e1", "e2")), code.gen=code_gen_arith,
  ##   res.type='preserve.int'
  ## ),
  # - Unary Ops ----------------------------------------------------------------

  ## + and - are remapped to uplus and uminus via a transform by cgen_bin as
  ## we don't allow the same function name to have different sizing methods
  list(
    cgen(
      "uplus", fun=uplus, type=list("arglen", "x"), code.gen=code_gen_unary,
      res.type="preserve.int"
    ),
    cgen(
      "uminus", fun=uminus, type=list("arglen", "x"), code.gen=code_gen_unary,
      res.type="preserve.int"
    ),
    cgen(
      "!", defn=function(x) NULL, type=list("arglen", "x"), code.gen=code_gen_unary,
      res.type="logical"
    )
  ),
  # - Sequence -----------------------------------------------------------------

  list(
    cgen(
      "seq_along", defn=function(along.with) NULL,
      type=list("arglen", "along.with"), code.gen=code_gen_seq_along,
      res.type='preserve'
    )
  ),
  # - Subset -----------------------------------------------------------------

  list(
    cgen(
      "[", defn=function(x, i) NULL,
      type=list("arglen", "i"), code.gen=code_gen_subset,
      res.type="preserve.which", res.type.which=1L,
      in.type.validate=subset_input_val
    ),
    # assign uses transform to generate subassign calls when child is `[`
    cgen(
      "subassign", fun=subassign,
      type=list("arglen", "x"), code.gen=code_gen_subassign,
      res.type="preserve.which", res.type.which=c(1L,3L),
      in.type.validate=subset_input_val
    )
  ),

  # - Other Logical ------------------------------------------------------------

  list(
    cgen(
      "&&", defn=BIN.DEFN,
      type=list("constant", 1), code.gen=code_gen_lgl2,
      res.type="logical"
    ),
    cgen(
      "||", defn=BIN.DEFN, type=list("constant", 1), code.gen=code_gen_lgl2,
      res.type="logical"
    ),
    cgen(
      "ifelse", type=list("arglen", "test"), code.gen=code_gen_ifelse,
      res.type="preserve" # not faithful to what R does
    )
  ),
  # - Assign / Control----------------------------------------------------------

  list(
    # see subset for [<-, although transform to subassign done here
    cgen(
      "<-", defn=function(x, value) NULL,
      type=list("arglen", "value"), code.gen=code_gen_assign,
      res.type="preserve.last", transform=assign_transform
    ),
    cgen(
      "=", defn=function(x, value) NULL,
      type=list("arglen", "value"), code.gen=code_gen_assign,
      res.type="preserve.last"
    ),
    cgen(
      "{", defn=function(...) NULL,
      # arglen of last argument matching dots
      type=list("arglen", "...", function(x) x[length(x)]),
      code.gen=code_gen_braces, res.type="preserve.last"
    ),
    # result of this one is not used outside of the C code
    cgen(
      "if_test", type=list("constant", 1), code.gen=code_gen_if_test,
      res.type="logical", fun=if_test
    ),
    cgen(
      "if_true", type=list("arglen", "expr"), code.gen=code_gen_if_true,
      fun=if_true, res.type="preserve"
    ),
    cgen(
      "if_false", type=list("arglen", "expr"), code.gen=code_gen_if_false,
      fun=if_false, res.type="preserve"
    ),
    # `res.type` gets special handling in `reconcile_control_flow` for `r2c_if`.
    cgen(
      "r2c_if", type=list("eqlen", c("true", "false")),
      code.gen=code_gen_r2c_if, fun=r2c_if, res.type="preserve"
    ),
    # This one can't actually generate code and needs to be first decomposed
    # into the above if_test/r2c_if/if_true/if_false, but we need it here so the
    # early parsing passes recognize it as an allowed function.
    cgen(
      "if",
      # This is special cased in match_call_rec.
      defn=function(cond, cons.expr, alt.expr) NULL, primitive.nomatch=TRUE,
      # Below not actually use due to decomposition of `if` -> `r2c_if`.
      type=list("eqlen", c('cons.expr', 'alt.expr')),
      code.gen=code_gen_if, res.type="preserve"
    ),
    # Result of this one is only used directly in C code, but passive pass
    # through of type so we need to preserve that.
    cgen(
      FOR.INIT, type=list("constant", 1), code.gen=code_gen_for_init,
      res.type="preserve.which", res.type.which=2L, fun=for_init
    ),
    cgen(
      "for_iter", type=list("constant", 1), code.gen=code_gen_for_iter,
      res.type="preserve.which", res.type.which=2L, fun=for_iter
    ),
    cgen(
      FOR.N, type=list("arglen", "expr"), code.gen=code_gen_for_n,
      fun=for_n, res.type="preserve"
    ),
    cgen(
      FOR.0, type=list("arglen", "expr"), code.gen=code_gen_for_0,
      fun=for_0, res.type="preserve"
    ),
    # `res.type` gets special handling in `reconcile_control_flow` for `r2c_if`.
    cgen(
      R2C.FOR, type=list("eqlen", c("for.n", "for.0")),
      code.gen=code_gen_r2c_for, fun=r2c_for, res.type="preserve"
    ),
    # This is a stub function like `if`.
    cgen(
      "for", defn=function(var, seq, expr) NULL, primitive.nomatch=TRUE,
      type=list("arglen", "expr"), code.gen=code_gen_for, res.type="preserve"
    )
  ),
  # - Miscellaneous ------------------------------------------------------------
  list(
    cgen(
      "numeric", defn=function(length=0L) NULL,
      # Is length redundant? One is to classify, and to the other compute size.
      type=list("extern", "length", numeric_size),
      extern=list(length=ext_par("num", valid_length)),
      code.gen=code_gen_numeric, res.type="double"
    ),
    cgen(
      "numeric_along", fun=numeric_along,
      type=list("arglen", "along.with"),
      code.gen=code_gen_numeric_along, res.type="double"
    ),
    cgen(
      "numeric_alongn", fun=numeric_alongn,
      type=list("prod", "..."),
      code.gen=code_gen_numeric_alongn, res.type="double"
    )
  ),
  # - r2c funs -----------------------------------------------------------------
  list(
    cgen(
      "mean1", fun=mean1,
      extern=list(na.rm=ext_par("num", valid_narm)),
      type=list("constant", 1),
      code.gen=code_gen_summary
    ),
    cgen(
      "square", fun=square, defn=square,
      type=list("arglen", "x"),
      code.gen=code_gen_square
    ),
    cgen(
      "vcopy", fun=vcopy,
      type=list("arglen", "x"),
      code.gen=code_gen_copy,
      res.type="preserve"   # for uplus
    ),
    cgen(
      "rec", fun=rec,
      type=list("arglen", "x"),
      code.gen=code_gen_rec,
      res.type="preserve"
    ),
    cgen(
      "lset", fun=lset,
      type=list("arglen", "x"),
      code.gen=code_gen_lset,
      res.type="preserve"
    ),
    cgen(
      "lrec", fun=lrec,
      type=list("arglen", "x"),
      code.gen=code_gen_lrec,
      res.type="preserve"
    )
  )
)
names(VALID_FUNS) <- vapply(VALID_FUNS, "[[", "", "name")
# even though we allow ::, we don't allow duplicate function names for
# simplicity.
stopifnot(
  !anyDuplicated(names(VALID_FUNS)),
  identical(sort(names(VALID_FUNS)), sort(names(FUN.NAMES)))
)

code_blank <- function()
  list(
    defn="", name="", call="", narg=FALSE, ext.any=FALSE,
    headers=character(), defines=character(), out.ctrl=CGEN.OUT.NONE
  )
code_valid <- function(code, call) {
  isTRUE(check <- vet(CHR.1, code[['defn']])) &&
    isTRUE(check <- vet(CHR.1, code[['name']])) &&
    isTRUE(check <- vet(CHR.1, code[['call']])) &&
    isTRUE(check <- vet(CHR || NULL, code[['headers']])) &&
    isTRUE(check <- vet(CHR || NULL, code[['defines']])) &&
    isTRUE(
      check <- vet(INT.1 && all_bw(., 0, CGEN.OUT.DFLT), code[['out.ctrl']])
    )
  if(!isTRUE(check))
    stop("Generated code format invalid for `", deparse1(call), "`:\n", check)

  TRUE
}
# Check whether a call is in valid format
#
# We allow pkg::fun for a select set of packages that r2c implements functions
# from.  Duplicate `fun` across packages is assumed impossible (just b/c we have
# not implemented such, and the assumption simplifies things).

call_valid <- function(call) {
  if(is.call(call)) {
    fun.c <- get_lang_info(call)
    pkg <- fun.c[['pkg']]
    fun <- fun.c[['name']]

    if(nzchar(pkg) && !pkg %in% VALID.PKG)
      stop(
        "Package `", pkg, "` not a supported package in ", deparse1(call)
      )
    else if (!nzchar(pkg) && !fun %in% names(VALID_FUNS))
      stop("`", fun, "` is not a supported function.")

    if(fun %in% INTERNAL.FUNS)
      stop(
        "`", fun,
        "` is an internal r2c function and invalid as an input to compilation."
      )
    if(fun == "{" && length(call) < 2L)
      stop("Empty braces {} disallowed in r2c expressions.")
    fun
  }

}
#' Default C Call Generation
#'
#' Calls outside of controls follow a clear pattern that this function
#' implements.  See `code_res` for parameter description.
#'
#' @noRd

c_call_gen <- function(name, narg, ext.any) {
  sprintf(
    "%s(%s%s%s);",
    name,
    toString(CALL.BASE),
    if(narg) paste0(", ", CALL.VAR) else "",
    if(ext.any) paste0(", ", CALL.EXTERN) else ""
  )
}
#' Organize C Code Generation Output
#'
#' There are three types of C output:
#'
#' * Call to the C function
#' * Definition of C function
#' * Deparsing of R function as comment for context
#'
#' Different R level calls require outputting different mixes of the above,
#' where the default standard call like `mean(x)` will output all three.
#' Exceptions include so called NO-OP calls that don't actually require a C
#' function call such as assignments or braces.  These don't compute anything
#' directly.  Additionally, control functions don't map R calls directly to C
#' calls, but still use proxy R calls as stand-ins for e.g. the braces, the
#' `else`, etc.  So those have an associated output that is "executed" at
#' run-time, but e.g. don't have corresponding definitions or deparsed R
#' commentary.
#'
#' Every R call, including proxy R calls, maintains a spot in the data
#' indexing, flag, and control arrays, even if they are not run at the C level.
#' This simplifies the logic of the allocation code.  Additionally, every R call
#' must generate a C function definition and a call, irrespective of whether the
#' definition and/or call are emitted to the final C output file.  This
#' requirement is due to some sanity checks that preceded the possibility of
#' calls/definitions that might not get emitted.
#'
#' @noRd
#' @seealso `cgen` for the actual C code generation, `preprocess` for the
#'   assembly into the final C file.
#' @param narg TRUE if function has variable number of arguments
#' @param ext.any TRUE if function has non-numeric external parameters
#' @param headers character vector with header names that need to be #included
#' @param defines character with #define directives
#' @param out.ctrl scalar integer sum of various `CGEN.OUT.*` constants (see
#'   constants.R) that control which parts of the C output are generated and
#'   how.  The actual final C file is produced by `preprocess` (consulting these
#'   values).
#' @param c.call.gen function to generate the C call.  Primarily used to allow
#'   generation of control flow code that follows different patterns than all
#'   the others, including cases where there is no function call at all, only
#'   e.g. braces or an else statement.

code_res <- function(
  defn, name, narg=FALSE, ext.any=FALSE,
  headers=character(), defines=character(), out.ctrl=CGEN.OUT.DFLT,
  c.call.gen=c_call_gen
) {
  if(is.na(name)) stop("Internal Error: mismapped function name.")
  if(
    bitwAnd(out.ctrl, CGEN.OUT.MUTE) && !name %in% FUN.NAMES[PASSIVE.SYM]
  )
    stop("Internal Error: cannot mute ", name, ", as not in PASSIVE.SYM")

  c_call <- paste0(
    c.call.gen(name, narg=narg, ext.any=ext.any), collapse="\n"
  )
  list(
    defn=defn, name=name,
    call=c_call,
    headers=if(is.null(headers)) character() else headers,
    defines=if(is.null(defines)) character() else defines,
    narg=narg, ext.any=ext.any, out.ctrl=out.ctrl
  )
}
