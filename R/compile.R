## Copyright (C) Brodie Gaslam
##
## This file is part of "r2c - Fast Iterated Statistic Computation in R"
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 or 3 of the License.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## Go to <https://www.r-project.org/Licenses> for copies of the licenses.

## Generate a Shared Library Object From C Code
##
## @param x character the C code to compile
## @return character file name of the SO; will be in a temporary directory, it is
##   the users responsibility to preserve and/or discard the file.

make_shlib <- function(x, dir, quiet) {
  if(!is.character(x) || anyNA(x))
    stop("Argument `x` must be character and free of NAs.")

  dir.create(dir)
  file.base <- file.path(dir, sprintf('r2c-%s', rand_string(10)))
  file.src <- paste0(file.base, ".c")
  file.obj <- paste0(file.base, .Platform$dynlib.ext)
  if(file.exists(file.src))
    stop(
      "Randomly generated file name ", file.src, "' already exists. ",
      "Bad luck?  Try again."
    )
  writeLines(x, file.src)
  comp.out <- system2(
    R.home("bin/R"), c("CMD", "SHLIB", file.src),
    stdout=TRUE, stderr=TRUE,
    env=paste0("PKG_CFLAGS=-I", system.file(package='r2c', 'headers'))
  )
  status <- attr(comp.out, 'status')
  if(!is.null(status) && status != 0) {
    writeLines(comp.out, stderr())
    stop("Compilation failed, see output above.n")
  }
  else if(!quiet) writeLines(comp.out)
  # is this what's returned on windows (we can specify, but should make sure if
  # the extension matters)?
  list(so=file.obj, out=comp.out)
}

rand_string <- function(len, pool=c(letters, 0:9))
  without_seed(paste0(sample(pool, len, replace=TRUE), collapse=""))

#' Compile Eligible R Calls Into Native Instructions
#'
#' The `r2c*` functions translate eligible R calls into C, compile them into
#' native instructions using `R CMD SHLIB`, and return an interface to that
#' code in the form of an "r2c_fun" function.  This function will carry out
#' out numerical calculations with `r2c` native instructions instead of with the
#' standard R routines. "r2c_fun" functions are intended to be run with the
#' `r2c` [runners] for fast iterated calculations.  `r2c` adheres closely to R
#' semantics for the supported use cases.  Look at the examples here and those
#' of the [runners] to get started.
#'
#' @section r2c Generated Functions:
#'
#' While "r2c_fun" functions can be called in the same way as normal R
#' functions, there is limited value in doing so.  "r2c_fun" functions are
#' optimized to be invoked invoked indirectly with [runners].  In many common
#' cases it is likely that using an "r2c_fun" directly instead of with a runner
#' will be slower than evaluating the corresponding R expression.
#'
#' The lifecycle of an `r2c` function has two stages.
#'
#' 1. Compilation, with `r2cq` or similar.
#' 2. Execution, either direct or via [runners], which comprises:
#'     * A one time memory allocation sized to largest iteration (this memory
#'       is re-used for every iteration).
#'     * Iterative execution over groups/windows.
#'
#' Each of the `r2c*` functions addresses different types of input:
#'
#' * `r2cf` generates an "r2c_fun" function from a regular R function.
#' * `r2cq` captures an unquoted R expression and turns it into an "r2c_fun"
#'   function (e.g. `r2cq(a + b)`).
#' * `r2cl` turns quoted R language (e.g. as generated by [`quote`]) into an
#'   "r2c_fun" function (e.g. `r2cl(quote(a + b))`).
#'
#' For `r2cl` and `r2cq`, symbols used as parameters to `call` and its
#' constituent sub-calls (e.g. the `x` and `y` in `sum(x) + y`) will become
#' parameters to the output "r2c_fun" function.  There must be at least one such
#' symbol in `call`.  Parameter order follows that of appearance in the call
#' tree after everything is [`match.call`]ed.  Symbols beginning with `.R2C` are
#' reserved for use by `r2c` and thus disallowed in `call`.  You may also
#' directly set the parameter list with the `formals` parameter, or with `r2cf`.
#'
#' As with regular R functions, unbound symbols  are resolved in the lexical
#' environment of the function.  You can set a different environment on creation
#' of the function with the `envir` parameter, but currently there is no way to
#' change it afterwards (`environment(r2c_fun) <- x` will likely just break the
#' function).
#'
#' @section Expression Types:
#'
#' Sub-expressions in an `r2c` expression are categorized as internal or
#' external.  Internal sub-expressions are computed anew each iteration,
#' whereas external ones are computed once at allocation time and the result is
#' re-used thereafter.  Which category a sub-expression is assigned to depends
#' on what function parameter it is matched to.  For example, in `sum(x,
#' na.rm=TRUE)`, `x` is considered an internal parameter and `na.rm` an
#' external parameter.  Additionally, symbols that resolve to iteration
#' varying or `r2c` computed data are considered internal, and other
#' symbols are considered external.  It is possible to use an external symbol as
#' the value of an internal parameter if it abides by the constraints imposed on
#' internal parameters.  Such symbols are evaluated as per external
#' sub-expression rules (see below).
#'
#' Internal sub-expressions must resolve to attribute-less atomic vectors.
#' Numeric, integer, and logical vectors are supported, but they are coerced to
#' numeric (double), and thus logical and integer vectors are copied before use.
#' All `r2c` operations are carried out on floating point values.  In cases
#' where the output type is knowable to be either integer or logical, `r2c` will
#' coerce the final result to the corresponding type with a copy.  To avoid
#' copies provide all inputs as doubles.
#'
#' External sub-expressions may be arbitrary R expressions, but if they are used
#' for internal parameters their result will be constrained like internal ones
#' are.  Such expressions should not reference internal symbols, and in cases
#' where this is obviously happening `r2c` will error.  External sub-expressions
#' are evaluated once at allocation time.  If the same sub-expression appears
#' more than once, it is only evaluated once with the result re-used.  External
#' sub-expressions that cause side-effects, use `eval`, manipulate frames, or
#' engage in other complex "meta" operations are likely to have different
#' effects than intended.
#'
#' The dichotomy between internal and external sub-expressions allows for
#' efficient mixing of iteration varying and static data, as well as non
#' numeric configuration parameters.
#'
#' @section Supported R Functions and Constraints:
#'
#' The following functions are supported in `x` (or in the body of `x` for
#' `r2cf`):
#'
#' * Arithmetic functions: `+`, `-`, `*`, `/`, and `^`.
#' * Relational functions: `<`, `<=`, `>`, `>=`, `==`, `!=`.
#' * Logical functions: `&`, `&&`, `|`, `||`, `!`, `ifelse`.
#' * Statistics: `mean`, `sum`, `length`, `all`, `any`.
#' * Assignment and braces: `<-`, `=`, and `{`.
#' * Control Structures (experimental): `if/else`, `for`
#' * Sequences: `seq_along`, `seq_len`, `rep`.
#' * Subsetting: `[`, `x[s] <- expr`
#' * Miscellaneous: `numeric`.
#'
#' Calls must be in the form `fun(...)` (`a fun b` for operators)  where `fun`
#' is the name of the function, optionally in `pkg::fun` format.  Functions must
#' be bound to their original symbols for them to be recognized.
#'
#' In general the r2c implementations will behave as in R.  There are several
#' exceptions, but outside of those involving control structures you will not
#' notice them in typical usage:
#'
#' * `ifelse` always return in a common type that can support
#'   both `yes` and `no` values.
#' * `&&` and `||` always evaluate all parameters.
#' * `{` must contain at least one parameter (no empty braces).
#' * `seq_along` always returns a double vector, never integer.
#' * `[` only supports strictly positive indices.
#' * `x[s] <- y`
#'     * May only be used for the side effect of changing `x` (i.e. the return
#'       value of the sub-assignment expression may not be used).
#'     * `s` may only contain values in `seq_along(x)`.
#'     * `"[<-"(x, s, y)` is considered distinct and disallowed.
#' * In `numeric(x)`, `seq_len(x)`, `rep(vec, times=x, each=y, length.out=z)`,
#'   `x`, `y`, and `z` are external parameters, i.e. they cannot be iteration
#'   varying (see "Expression Types", also `?numeric_along`).  Additionally
#'   `rep` does not take any `...` parameters.
#' * Assignments may only be nested in braces (`{`) or in control structure
#'   branches.  This is a recursive requirement, so `mean(if(a) x <- y)` is
#'   disallowed even though `if(a) x <- y` is allowed.
#'
#' @section Control Structures:
#'
#' `r2c` supports `if` / `else` statements and `for` loops on an experimental
#' basis.  These substantially complicate the internals of `r2c` and as such
#' might be removed in the future.
#'
#' Both `if` / `else` and `for` loops have branches; the loop branches are loop
#' not taken (0 iterations) vs loop taken (1+ iterations).  Branches add
#' constraints not present in R:
#'
#' * Control structure return values must be guaranteed to be the same
#'   size irrespective of the branch taken, if they are subsequently used.
#'   Return values are coerced to a common type.
#' * Assignments made within control structure branches must be guaranteed to be
#'   the same size irrespective of branch taken, if the corresponding bindings
#'   are subsequently used.
#' * Control structures can be nested at most 999 levels.
#'
#' There are also minor semantic differences:
#'
#' * `if`/`else` and `for` both return `numeric(0)` instead of NULL when in R
#'   they  would return NULL.
#' * `for` sets `var` to NA_real_ if `length(seq) == 0` instead of NULL.
#'
#' Like R, `r2c` is optimized for vectorized operations.  While you can write
#' explicit loops with `for`, they will be much slower than a pure C version,
#' and only marginally faster than byte compiled R equivalents.  Avoid `for`
#' loops unless you cannot express your calculation in an internally vectorized
#' form (see examples).
#'
#' @section Details:
#'
#' `r2c` will [r2c-preprocess][preprocess] the provided call either to apply
#' optimizations (see `optimize` parameter), or because a call needs to be
#' modified to work correctly with `r2c`.  The processing leaves call semantics
#' unchanged.  If `r2c` modified a call, [`get_r_code`] will show a "processed"
#' member with the modified call.
#'
#' `r2c` requires a C99 or later compatible implementation with floating point
#' infinity defined and the `R_xlen_t` range representable without precision
#' loss as double precision floating point.  Platforms that support R and fail
#' this requirement are likely rare.
#'
#' Interrupts are supported at the [runner] level, e.g. _between_ groups or
#' windows, each time a preset number of elements has been processed since the
#' last interrupt check.  There is infrastructure to support within
#' iteration-interrupts, but it adds overhead when dealing with many iterations
#' with few elements each and thus is disabled at the moment.
#'
#' The structure of "r2c_fun" functions is subject to change without notice in
#' future `r2c` releases.  The only supported uses of them are standard
#' invocation with the `(` operator and use with the [runners].
#'
#' @export
#' @param x an object to compile into an "r2c_fun", for `r2cf` an R function,
#'   for `r2cq` an expression that will be captured unevaluated, for `r2cl` an R
#'   expression escaped with [`quote`].  See details.
#' @param formals character vector of the names of the parameters for the
#'   resulting "r2c_fun", a list of formals as generated with e.g. [`alist`], or
#'   NULL (default).  NULL causes all free symbols in `x` to become parameters
#'   to the result "r2c_fun" in the order they appear in `x`'s call tree (see
#'   details).  Non-default values can be used to specify different parameter
#'   order, and in the list form also to specify default values for parameters.
#'   Symbols in `x` not in `formals` will be resolved against the evaluation
#'   environment at run time.
#' @param dir NULL (default), or character(1L) name of a file system directory
#'   to store the shared object file in.  If NULL a temporary directory will be
#'   used. The shared object will also be loaded, and if `dir` is NULL the
#'   directory with the file will be removed after loading.  Currently the
#'   capability to re-use generated shared objects across R sessions is not
#'   formally supported, but can likely be arranged for by preserving the
#'   directory.
#' @param check TRUE or FALSE (default), if TRUE will evaluate the R expression
#'   with the input data and compare that result to the one obtained from the
#'   `r2c` C code evaluation, marking the result with attributes that indicate
#'   that the result was identical, and if not, also with an attribute with the
#'   result of an `all.equal` comparison.  The check is only carried out when an
#'   `r2c` function is invoked directly (see example).
#' @param clean TRUE or FALSE, whether to remove the `dir` folder containing the
#'   generated C code and the shared object file after the shared object is
#'   [`dyn.load`]ed.  Normally this is an auto-generated temporary folder.  This
#'   will only delete folders that have the same directory root as one generated
#'   by `tempfile()` to avoid accidents.  If you manually provide `dir` you will
#'   need to manually delete the directory yourself.
#' @param optimize TRUE (default) or FALSE whether to enable "compiler"
#'   optimizations. Currently it is just the automatic re-use of repeated
#'   computation results.  You can use [`get_r_code`] to see if optimizations
#'   were applied.
#' @param envir environment to use as the enclosure of the function evaluation
#'   environment.  It defaults to the environment from which the compilation
#'   function is called, or for `r2cf` the environment of `fun`.  See details.
#' @param quiet whether to suppress the compilation output.
#' @param TRUE, FALSE, or an integer setting optimization levels.  Currently
#'   applies [`reuse_calls`] if not FALSE or 0.
#' @return an "r2c_fun" function; this is an unusual function so please see
#'   details.
#' @name r2c-compile
#' @aliases r2cf
#' @seealso [`runners`] to iterate "r2c_fun" functions on varying data,
#'   [`r2c-inspect`] for functions to retrieve meta data from the function,
#'   including the generated C code and the compiler output,
#'   [preprocessing][r2c-preprocess] for how `r2c` modifies R calls before
#'   translation to C.
#' @examples
#' r2c_sum_sub <- r2cq(sum(x - y))
#' r2c_sum_sub <- r2cl(quote(sum(x - y)))  ## equivalently
#' sum_sub <- function(x, y) sum(x - y)
#' r2c_sum_sub <- r2cf(sum_sub)            ## equivalently
#' r2c_sum_sub(-1, c(1, 2, 3))
#'
#' ## Set parameter order for r2cq
#' r2c_sum_sub2 <- r2cq(sum(x - y), formals=c('y', 'x'))
#' r2c_sum_sub2(-1, c(1, 2, 3))
#'
#' ## Leave symbols unbound, here `y` is resolved in the lexical environment
#' r2c_sum_sub3 <- r2cq(sum(x - y), formals='x')
#' y <- 999
#' local({y <- -1; r2c_sum_sub3(c(1, 2, 3))})
#'
#' ##  Make a version that is checked
#' r2c_sum_check <- r2cq(sum(x), check=TRUE)
#' r2c_sum_check(1:10)                                 # checked
#'
#' ## Checks are disabled when using runners
#' group_exec(r2c_sum_check, 1:10, groups=rep(1L, 10)) # not checked
#'
#' ## Multi-line statements with assignments are supported
#' slope <- function(x, y) {
#'   mux <- mean(x)
#'   x_mux <- x - mux
#'   sum(x_mux * (y - mean(y))) / sum(x_mux^2)
#' }
#' r2c_slope <- r2cf(slope)
#' u <- runif(10)
#' v <- runif(10)
#' r2c_slope(u, v)
#'
#' ## Note `r2c` automatically optimizes re-used calls, so intermediate
#' ## assignments may be unnecessary:
#' slope2 <- function(x, y)
#'   sum((x - mean(x)) * (y - mean(y))) / sum((x - mean(x))^2)
#' r2c_slope2 <- r2cf(slope2)
#' get_r_code(r2c_slope2)
#' identical(r2c_slope(u, v), r2c_slope2(u, v))
#'
#' ## But assignments in arguments to other calls are disallowed
#' slope2 <- function(x, y)
#'   sum((x_mux <- x - mean(x)) * (y - mean(y))) / sum(x_mux^2)
#' try(r2c_slope2 <- r2cf(slope2))  # Error
#'
#' ## For loops are slow; don't use them when there is an internally
#' ## vectorized alternative.
#' sum_prod_loop_r <- function(x, y) {
#'   res <- 0
#'   for(i in seq_along(x)) res <- res + x[i] * y[i]
#'   res
#' }
#' sum_prod_loop <- r2cf(sum_prod_loop_r)
#' sum_prod_vec <- r2cq(sum(x * y))
#' a <- runif(5e6)
#' system.time(sum_prod_vec(a, a))
#' system.time(sum_prod_loop(a, a))
#' ## Make sure R fun byte-compiled
#' sum_prod_loop_r <- compiler::cmpfun(sum_prod_loop_r)
#' system.time(sum_prod_loop_r(a, a))

r2cf <- function(
  x, dir=NULL, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE), clean=is.null(dir),
  optimize=getOption('r2c.optimize', TRUE), envir=environment(x)
)
  r2c_core(
    body(x), formals=as.list(formals(x)),
    dir=dir, check=check, quiet=quiet, clean=clean, optimize=optimize,
    envir=envir
  )

#' @export
#' @rdname r2c-compile

r2cl <- function(
  x, formals=NULL, dir=NULL, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE), clean=is.null(dir),
  optimize=getOption('r2c.optimize', TRUE), envir=parent.frame()
)
  r2c_core(
    x, formals=formals, dir=dir, check=check, quiet=quiet,
    clean=clean, optimize=optimize, envir=envir
  )

#' @export
#' @rdname r2c-compile

r2cq <- function(
  x, formals=NULL, dir=NULL, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE), clean=is.null(dir),
  optimize=getOption('r2c.optimize', TRUE), envir=parent.frame()
)
  r2c_core(
    substitute(x), formals=formals, dir=dir, check=check, quiet=quiet,
    clean=clean, optimize=optimize, envir=envir
  )


r2c_core <- function(
  call, formals, dir, check, quiet, clean, optimize, envir
) {
  vetr(
    is.language(.), (list() && !is.null(names(.))) || NULL || CHR,
    dir=CHR.1 || NULL, check=LGL.1, quiet=LGL.1, clean=LGL.1,
    optimize=LGL.1 || INT.1.POS, envir=is.environment(.)
  )
  auto.formals <- FALSE
  if(is.character(formals)) {
    frm.names <- formals
    formals <- replicate(length(formals), alist(a=))
    names(formals) <- frm.names
  } else if(is.null(formals)) {
    auto.formals <- TRUE
    formals <- list()
    names(formals) <- character()
  }
  # Parse R expression and Generate the C code
  preproc <- preprocess(call, optimize=optimize)
  optimized <- optimize && !identical(call, preproc[['call.processed']])

  # Generate directory, use dirname/basename to normalize it to same format as
  # file.path
  if(is.null(dir)) dir <- tempfile()
  dir <- file.path(dirname(dir), basename(dir))

  # Compile C code
  so <- make_shlib(preproc[['code']], dir=dir, quiet=quiet)
  # Pre-load lib as by default we don't keep the SO file

  # But if we do keep it, we want to be able to recover it later.  We store the
  # data in an environment for deparse into <environment> instead of a list.
  OBJ <- list2env(
    list(
      preproc=preproc, so=so[['so']],
      handle=list(name="r2c"),  # dummy handle should return FALSE w/ is.loaded
      call=call, call.processed=preproc[['call.processed']],
      compile.out=so[['out']],
      R.version=R.version, r2c.version=utils::packageVersion('r2c'),
      envir=envir
    ),
    parent=emptyenv()
  )
  OBJ[['handle']] <- load_dynlib(OBJ)
  if(clean) unlink(dir, recursive=TRUE)

  # Generate formals that match the free symbols in the call
  if(auto.formals) {
    sym.free <- preproc[['sym.free']]
    # Anything bad happen if we allow the below through?
    if(!length(sym.free))
      stop(
        "Expression does not contain any parameter symbols:\n",
        deparseLines(call)
      )
    formals <- replicate(length(sym.free), alist(a=))
    names(formals) <- sym.free
  }
  fun <- fun.dummy <- function() NULL
  formals(fun) <- formals

  # The generated function needs to be be callable stand-alone, and useable by
  # runners like group_exec.  We have the following requirements:
  #
  # 1. We need the function itself to be able to recover the `r2c` object data,
  #    which means we need to embed the actual object (not a symbol referencing
  #    it) in the function (we could alternatively use the `sys.call()` trick
  #    from `rlang` to get the attribute, but that feels like it relies on an
  #    implementation detail).
  # 2. We need the function to survive a re-loading of r2c (for safety no runner
  #    allows running r2c_fun compiled with different R/r2c versions).
  #
  # Thus, we directly embed the object with `.(OBJ)`. We use the same trick for
  # several other objects, both directly those generated here, and also those
  # that will be generated at call time, to ensure that no run-time objects can
  # interfere with the symbol resolution of the "r2c_fun" against its
  # parameters.

  # Generate the docstring that will appear at beginning of function
  DOC <- as.call(
    list(
      as.name("{"),
      c(
        strrep("-", 60),
        paste0("| ",
          format(
            c(
              "**R2C** implementation of:", strrep(" ", 60),
              deparse(call, width.cutoff=40),
              if(check || optimized)
                c(
                  "",
                  if(check) "self-check ON",
                  if(optimized) "optimize ON (see `?get_r_code`)",
                  ""
                )
        ) ) ),
        paste0("+", strrep("-", 61))
  ) ) )
  # See below, we can't do this inline as it would be nested bquote
  FORCE <- quote(eval(bquote(list(.(as.name(i))))))
  # All required variables and meta-data; DOC and OBJ are embedded as
  # actual R objects, not unevaluated symbols like the rest.
  PREAMBLE <- bquote({
    .(DOC)
    .(OBJ)  # for ease of access, embedded in actual fun later
    try <- tryCatch(
      .DAT0 <- as.list(environment(), all.names=TRUE), error=function(e) e
    )
    .CALL <- sys.call()
    if(inherits(try, 'simpleError'))
      stop(simpleError(conditionMessage(try), .CALL))
    .DAT <- if(dot.pos <- match('...', names(.DAT0), nomatch=0))
      tryCatch(
        c(
          .DAT0[seq_len(dot.pos - 1L)], list(...),
          .DAT0[seq_len(length(.DAT0) - dot.pos) + dot.pos]
        ),
        error=function(e) stop(simpleError(conditionMessage(e), .CALL))
      )
    else .DAT0
    .DGRP <- if(length(.DAT)) .DAT[1L] else list()
    .FRM <- formals()
    # Correct lexical enclosure.  We cannot give The "r2c_fun" this
    # enclosure because that would change the search path for all funs here.
    .ENV <- list2env(.DAT0, parent=.(envir))
  })
  # We'll use group_exec with a single group to act as the runner for the
  # stand-alone use of this function, so use `groups=NULL`.
  GEXE <- quote(
    bquote(
      group_exec_int(
        NULL, formals=.(.FRM), groups=NULL,
        # Pretend first argument is group-varying, even though it's not
        data=.(.DGRP), MoreArgs=.(.DAT[-1L]), call=quote(.(.CALL))
  ) ) )
  GEXE[[c(2L, 2L)]] <- OBJ  # embed object directly in call (replaces 1st NULL)

  # Assemble the full function, we have a normal version, and a self check
  # version that compares against normal eval.
  body(fun) <- if(!check) {
    bquote({
      .(PREAMBLE)
      eval(.(GEXE), envir=getNamespace('r2c'))
    })
  } else {
    # Symbol creation is ordered so that no created symbols will interfere with
    # symbols referenced in the evaluated expressions (i.e. `call` is
    # evaluated first when there are no symbols in the r2c_fun env).
    bquote({
      .(PREAMBLE)
      test.i <- identical(
        res0 <- evalq(.(call), envir=.ENV),
        res1 <- eval(.(GEXE), envir=getNamespace('r2c'))
      )
      test.ae <- if(!test.i) all.equal(res0, res1)
      attr(res1, 'r2c.check.identical') <- test.i
      attr(res1, 'r2c.check.all.equal') <- test.ae
      res1
    })
  }
  class(fun) <- "r2c_fun"
  fun
}

#' Extract Data from "r2c_fun" Objects
#'
#' "r2c_fun" functions contain embedded data used by the runners to call the
#' compiled native code associated with the functions.  The functions documented
#' here extract various aspects of this data.
#'
#' * `get_so_loc` the file system location of the shared object file.
#' * `get_c_code` the generated C code used to produce the shared object, but
#'   for quick inspection `show_c_code` is best.
#' * `show_c_code` retrieves code with `get_c_code` and outputs to screen the
#'   portion corresponding to the compiled expression, or optionally all of it.
#' * `get_r_code` the R call that was translated into the C code; if
#'   processing modified the original call the processed version will also be
#'   shown (see [`r2cq`]).
#' * `get_compile_out` the "stdout" produced during the compilation of the
#'   shared object.
#'
#' Most calls seen in the raw version of what `get_r_code` returns will have a C
#' level counterpart labeled with the R call in a comment.  This includes calls
#' that are nested as arguments to other calls, which will appear before the
#' outer call.  Due to how how control structures are implemented the R calls
#' and the C level counterparts will not match up exactly.
#'
#' @name r2c-inspect
#' @seealso [`r2c-compile`], [`r2c-preprocess`].
#' @export
#' @param fun an "r2c_fun" function as generated by e.g. [`r2c`].
#' @param all TRUE or FALSE (default) whether to retrieve all of the C code, or
#'   just the portion directly corresponding to the translated R expression.
#' @param raw TRUE or FALSE (default) whether to display the processed R code
#'   exactly as `r2c` will use it, or to simplify it to make easier to read.  If
#'   a simplification occurred the processed member name will be "processed*".
#' @return for `get_r_code` a list with on or two members, the first "original"
#'   is the R language object provided to the [compilation
#'   functions][r2c-compile], the second "processed" (or "processed*", see `raw`
#'   parameter) is the version that the C code is based on.  For all other
#'   functions a character vector, invisibly for `show_c_code`.
#' @examples
#' r2c_sum_sub <- r2cq(sum(x + y))
#' get_r_code(r2c_sum_sub)
#' show_c_code(r2c_sum_sub)

get_c_code <- function(fun, all=TRUE) {
  vetr(all=LGL.1)
  code <- get_r2c_dat(fun)[['preproc']][['code']]
  if(!all) {
    start <- grep('^void run\\(', code)
    if(length(start) != 1L) stop("Could not detect runner function.")
    code <- code[seq(start, length(code))]
  }
  code
}

#' @export
#' @rdname r2c-inspect

get_r_code <- function(fun, raw=FALSE) {
  vetr(raw=LGL.1)

  orig <- get_r2c_dat(fun)[['call']]
  processed <- get_r2c_dat(fun)[['call.processed']]
  res <- list()
  different <- !identical(orig, processed)
  final <- if(!raw) clean_call(processed) else processed
  res[['original']] <- orig
  processed.name <-
    if(!identical(final, processed)) 'processed*' else 'processed'
  if(different) res[[processed.name]] <- final
  res
}
# Make the call a little friendlier
#
# In theory we could drop names when input was wholly positionally matched, but
# that's going to be annoying to trace back.  At some point we were planning on
# having the indices into the original call available, but didn't follow through
# because we would have to attach that as an attribute or somesuch (and
# we can't do that for leaves anyway?).
#
# @param level how aggressively to clean, if 2L will also remove calls
#   associated with reconciliation (e.g. vcopy/rec).

clean_call <- function(x, level=1L) {
  fun.name <- get_lang_name(x)
  if(is.call(x) && fun.name %in% REC.FUNS && level == 2L) {
    # drop e.g. vcopy/rec
    x <- clean_call(x[[2L]], level=level)
  } else if(is.call_w_args(x)) {
    if(get_lang_name(x) == "subassign") {
      x <- en_assign(call("[", x[[2L]], x[[3L]]), x[[4L]])
    }
    # Drop dots from e.g. `sum(...=x, )`
    if(!is.null(names(x))) names(x)[names(x) == "..."] <- ""
    # Drop defaults that are set to default values
    fun.defn <- VALID_FUNS[[c(fun.name, 'defn')]]
    if(!is.null(fun.defn) && !is.null(names(x))) {
      defn.frm <- formals(fun.defn)
      default.args <- default_params(defn.frm)
      default.args.nm <- names(defn.frm)[default.args]
      act.def.equal <- vapply(
        default.args.nm,
        function(i) !is.null(defn.frm[[i]]) && identical(defn.frm[[i]], x[[i]]),
        TRUE
      )
      x[default.args.nm[act.def.equal]] <- NULL
    }
    # Drop names if only one param
    if(length(x) == 2L) names(x) <- NULL

    # Undo the if decomposition
    x <- recompose_control(x)

    # Recurse
    if(length(x) > 1L) # Dropping default args can shorten call
      for(i in seq(2L, length(x))) x[[i]] <- clean_call(x[[i]], level=level)
  }
  x
}

#' @export
#' @rdname r2c-inspect

get_so_loc <- function(fun) get_r2c_dat(fun)[['so']]

#' @export
#' @rdname r2c-inspect

get_compile_out <- function(fun) get_r2c_dat(fun)[['compile.out']]

#' @export
#' @rdname r2c-inspect

show_c_code <- function(fun, all=FALSE) {
  vetr(all=LGL.1)
  code <- get_c_code(fun, all=all)
  writeLines(code)
  invisible(code)
}

get_r2c_dat <- function(fun) {
  vetr(is.function(.) && inherits(., "r2c_fun"))
  dat <- try(body(fun)[[c(2L,3L)]])
  if(inherits(try, "try-error"))
    stop("`fun` does not appear to be structured like an r2c function.")
  if(!is.environment(dat))
    stop("Could not find data environment in `fun`")

  dat.contents <- c(
    'preproc', 'call', 'call.processed', 'so', 'compile.out',
    'R.version', 'r2c.version'
  )
  if(!all(dat.contents %in% ls(dat)))
    stop("`fun` missing some expected components.")
  if(!identical(dat[['R.version']], R.version))
    stop(
      "`fun` was compiled with a different R.version:\n\n",
      paste0(
        utils::capture.output(print(dat.contents[['R.version']])),
        collapse="\n"
    ) )
  if(!identical(dat[['r2c.version']], utils::packageVersion('r2c')))
    stop(
      "`fun` was compiled with a different r2c verson (",
      dat.contents[['r2c.version']], ")"
    )

  dat
}

## Load a DLL and Register Finalizer to Unload It
##
## @param obj environment r2c object

load_dynlib <- function(obj) {
  shlib <- obj[['so']]
  handle <- obj[['handle']]
  if(file.exists(shlib) && !is.loaded("run", PACKAGE=handle[['name']])) {
    obj[['handle']] <- handle <- dyn.load(shlib)
    reg.finalizer(obj, function(obj) dyn.unload(obj[['so']]))
  }
  if(!is.loaded("run", PACKAGE=handle[['name']]))
    stop("Could not load native code.")
  handle
}

