## Copyright (C) Brodie Gaslam
##
## This file is part of "r2c - Fast Iterated Statistic Computation in R"
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 or 3 of the License.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## Go to <https://www.r-project.org/Licenses> for copies of the licenses.

## Generate a Shared Library Object From C Code
##
## @param x character the C code to compile
## @return character file name of the SO; will be in a temporary directory, it is
##   the users responsibility to preserve and/or discard the file.

make_shlib <- function(x, dir, quiet) {
  if(!is.character(x) || anyNA(x))
    stop("Argument `x` must be character and free of NAs.")

  dir.create(dir)
  file.base <- file.path(dir, sprintf('r2c-%s', rand_string(10)))
  file.src <- paste0(file.base, ".c")
  file.obj <- paste0(file.base, .Platform$dynlib.ext)
  if(file.exists(file.src)) # this should not be able to happen v0.4 onwards
    stop(
      "Randomly generated file name ", file.src, "' already exists. ",
      "Bad luck?  Try again."
    )
  writeLines(x, file.src)
  comp.out <- system2(
    R.home("bin/R"), c("CMD", "SHLIB", file.src),
    stdout=TRUE, stderr=TRUE
  )
  status <- attr(comp.out, 'status')
  if(!is.null(status) && status != 0) {
    writeLines(comp.out, stderr())
    stop("Compilation failed, see output above.")
  }
  else if(!quiet) writeLines(comp.out)
  # is this what's returned on windows (we can specify, but should make sure if
  # the extension matters)?
  list(so=file.obj, out=comp.out)
}

rand_string <- function(len, pool=c(letters, 0:9))
  without_seed(paste0(sample(pool, len, replace=TRUE), collapse=""))

#' Compile Eligible R Calls Into Native Instructions
#'
#' The `r2c*` compilation functions translate [supported R
#' function calls][r2c-supported-funs] into C, compile them into native
#' instructions using `R CMD SHLIB`, and return an interface to that code in the
#' form of an "r2c_fun" function.  This function will carry out out numerical
#' calculations with `r2c` native instructions instead of with the standard R
#' routines, with the exception of some
#' [iteration-constant][r2c-expression-types] calls. "r2c_fun" functions are
#' intended to be run with the `r2c` [runners] for fast iterated calculations.
#' Look at the examples here and those of the [runners] to get started.
#'
#' @section r2c Generated Functions:
#'
#' While "r2c_fun" functions can be called in the same way as normal R
#' functions, there is limited value in doing so.  "r2c_fun" functions are
#' optimized to be invoked indirectly with [runners].  In many common
#' cases using an "r2c_fun" directly instead of with a runner could be slower
#' than evaluating the corresponding R expression.
#'
#' The lifecycle of an `r2c` function has two stages.
#'
#' 1. Compilation, with `r2cq` or similar.
#' 2. Execution, either direct or via [runners], which comprises:
#'     * A one time memory allocation sized to largest iteration (this memory
#'       is re-used for every iteration).
#'     * Iterative execution over groups/windows.
#'
#' Each of the `r2c*` functions addresses different types of input:
#'
#' * `r2cf` generates an "r2c_fun" function from a regular R function.
#' * `r2cq` captures an unquoted R expression and turns it into an "r2c_fun"
#'   function (e.g. `r2cq(a + b)`).
#' * `r2cl` turns quoted R language (e.g. as generated by [`quote`]) into an
#'   "r2c_fun" function (e.g. `r2cl(quote(a + b))`).
#'
#' For `r2cl` and `r2cq`, free symbols used as parameters to `call` and its
#' constituent sub-calls (e.g. the `x` and `y` in `sum(x) + y`) will become
#' parameters to the output "r2c_fun" function.  There must be at least one such
#' symbol in `call`.  Parameter order follows that of appearance in the
#' call tree after everything is [`match.call`]ed.  Symbols beginning with
#' `.R2C` are reserved for use by `r2c` and thus disallowed in `call`.  You may
#' also directly set the parameter list with the `formals` parameter, or with
#' `r2cf`.
#'
#' As with regular R functions, unbound symbols are resolved in the lexical
#' environment of the function.  You can set a different environment on creation
#' of the function with the `envir` parameter, but currently there is no way to
#' change it afterwards (`environment(r2c_fun) <- x` will likely just break the
#' function).
#'
#' Users should not rely on specifics of the internal structure of "r2c_fun"
#' functions; these are subject to change without notice in future `r2c`
#' releases.  The only supported uses of "r2c_fun" functions are use with the
#' [runners], standard invocation with the `(` operator, and other `r2c`
#' functions that accept "r2c_fun" functions as arguments (in particular the
#' [data retrieval functions][r2c-inspect]).
#'
#' @section Preprocessing and Compilation:
#'
#' `r2c` will [preprocess][r2c-preprocess] the provided call either to apply
#' optimizations (see `optimize` parameter), or because a call needs to be
#' modified to work correctly with `r2c`.  The processing leaves call semantics
#' unchanged.  If `r2c` modified a call, [`get_r_code`] will show a "processed"
#' member with the modified call.
#'
#' Compilation is done by writing a C file to a temporary directory and running
#' `R CMD SHLIB` on it.  Some binary distributions of R do not include this
#' command by default (see [`utils::SHLIB`]). The file contents and the shared
#' object contents are preserved as part of the ["r2c_fun"
#' object][r2c-introspect], and the temporary directory is deleted.
#'
#' `r2c` requires a C99 or later compatible implementation with floating point
#' infinity defined and the `R_xlen_t` range representable without precision
#' loss as double precision floating point.  Platforms that support R and fail
#' this requirement are likely rare.
#'
#' @note Interrupts are supported at the [runner][runners] level, e.g. _between_
#' groups or windows, each time a preset number of elements has been processed
#' since the last interrupt check.  There is infrastructure to support within
#' iteration-interrupts, but it adds overhead when dealing with many iterations
#' with few elements each and thus is disabled at the moment.
#'
#' @export
#' @param x an object to compile into an "r2c_fun", for `r2cf` an R function,
#'   for `r2cq` an expression that will be captured unevaluated, for `r2cl` an R
#'   expression escaped with [`quote`].  See details.
#' @param formals character vector of the names of the parameters for the
#'   resulting "r2c_fun", a list of formals as generated with e.g. [`alist`], or
#'   NULL (default).  NULL causes all free symbols in `x` to become parameters
#'   to the result "r2c_fun" in the order they appear in `x`'s call tree (see
#'   details).  Non-default values can be used to specify different parameter
#'   order, and in the list form also to specify default values for parameters.
#'   Symbols in `x` not in `formals` will be resolved against the evaluation
#'   environment at run time.
#' @param check TRUE or FALSE (default), if TRUE and the "r2c_fun" is invoked
#'   directly (as opposed to via [runners]), will compare the result of
#'   evaluating the expression in R against that of using the `r2c` C routines.
#'   The result is marked with attributes indicating whether the two evaluations
#'   are identical, and if they are not also with an attribute with the result
#'   of an `all.equal` comparison of the evaluations.
#' @param optimize TRUE (default) or FALSE whether to enable "compiler"
#'   optimizations. Currently it is just the automatic re-use of repeated
#'   computation results.  You can use [`get_r_code`] to see if optimizations
#'   were applied.
#' @param envir environment to use as the enclosure of the function evaluation
#'   environment.  It defaults to the environment from which the compilation
#'   function is called, or for `r2cf` the environment of `fun`.  See details.
#' @param quiet whether to suppress the compilation output.
#' @return an "r2c_fun" function; this is an unusual function so please see
#'   details.
#' @name r2c-compile
#' @aliases r2cf
#' @seealso [`runners`] to iterate "r2c_fun" functions on varying data,
#'   [inspection functions][r2c-inspect] to retrieve meta data from the function
#'   including the generated C code and the compiler output,
#'   [preprocessing][r2c-preprocess] for how `r2c` modifies R calls before
#'   translation to C, [package overview][r2c] for other `r2c` concepts.
#' @examples
#' r2c_mean_area <- r2cq(mean(x * y))
#' ## Equivalently with `r2cl` or `r2cf`
#' \dontrun{
#' r2c_mean_area <- r2cl(quote(mean(x * y)))
#' mean_area <- function(x, y) mean(x * y)
#' r2c_mean_area <- r2cf(mean_area)}
#'
#' ## Intended use is with runners
#' with(
#'   iris,
#'   group_exec(r2c_mean_area, list(Sepal.Width, Sepal.Length), Species)
#' )
#' ## Direct invocation supported but, it is of limited value.
#' with(iris, r2c_mean_area(Sepal.Width, Sepal.Length))
#'
#' ## Set parameter order for r2cq
#' r2c_sum_sub <- r2cq(sum(x - y), formals=c('y', 'x'))
#' ## Equivalently with `r2cf`
#' \dontrun{
#' r2c_sum_sub <- r2cf(function(y, x) sum(x - y))}
#' r2c_sum_sub(-1, c(1, 2, 3))

r2cf <- function(
  x, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE),
  optimize=getOption('r2c.optimize', TRUE), envir=environment(x)
)
  r2c_core(
    body(x), formals=as.list(formals(x)),
    check=check, quiet=quiet, optimize=optimize,
    envir=envir
  )

#' @export
#' @rdname r2c-compile

r2cl <- function(
  x, formals=NULL, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE),
  optimize=getOption('r2c.optimize', TRUE), envir=parent.frame()
)
  r2c_core(
    x, formals=formals, check=check, quiet=quiet,
    optimize=optimize, envir=envir
  )

#' @export
#' @rdname r2c-compile

r2cq <- function(
  x, formals=NULL, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE),
  optimize=getOption('r2c.optimize', TRUE), envir=parent.frame()
)
  r2c_core(
    substitute(x), formals=formals, check=check, quiet=quiet,
    optimize=optimize, envir=envir
  )


r2c_core <- function(
  call, formals, check, quiet, optimize, envir
) {
  vetr(
    is.language(.), (list() && !is.null(names(.))) || NULL || CHR,
    check=LGL.1, quiet=LGL.1,
    optimize=LGL.1 || INT.1.POS, envir=is.environment(.)
  )
  auto.formals <- FALSE
  if(is.character(formals)) {
    frm.names <- formals
    formals <- replicate(length(formals), alist(a=))
    names(formals) <- frm.names
  } else if(is.null(formals)) {
    auto.formals <- TRUE
    formals <- list()
    names(formals) <- character()
  }
  # Parse R expression and Generate the C code
  preproc <- preprocess(call, optimize=optimize)
  optimized <- optimize && !identical(call, preproc[['call.processed']])

  # Generate directory, use dirname/basename to normalize it to same format as
  # file.path (why?)
  dir <- tempfile()
  dir <- file.path(dirname(dir), basename(dir))

  # Compile C code and recover the contents of the SO file, and cleanup
  so <- make_shlib(preproc[['code']], dir=dir, quiet=quiet)
  so.disk <- so[['so']]
  so.bin <- readBin(so.disk, what='raw', file.size(so.disk))
  unlink(dir, recursive=TRUE)

  # Initialize the "r2c_fun" data, including loading the library.
  .OBJ <- list2env(
    list(
      preproc=preproc, so=so.bin,
      handle=list(name="r2c"),  # dummy handle should return FALSE w/ is.loaded
      call=call, call.processed=preproc[['call.processed']],
      compile.out=so[['out']],
      R.version=R.version, r2c.version=utils::packageVersion('r2c'),
      envir=envir
    ),
    parent=emptyenv()
  )
  .OBJ[['handle']] <- load_dynlib(.OBJ)

  # Generate formals that match the free symbols in the call
  if(auto.formals) {
    sym.free <- preproc[['sym.free']]
    # Anything bad happen if we allow the below through?
    if(!length(sym.free))
      stop(
        "Expression does not contain any parameter symbols:\n",
        deparseLines(call)
      )
    formals <- replicate(length(sym.free), alist(a=))
    names(formals) <- sym.free
  }
  if(length(formals.bad <- grep(R2C.PRIV.RX, formals, value=TRUE))) {
    stop(
      "Function formals may not match this regex: \"", R2C.PRIV.RX, "\":\n\n",
      toString(formals.bad)
    )
  }
  fun <- fun.dummy <- function() NULL
  formals(fun) <- formals

  # The generated function needs to be be callable stand-alone, and useable by
  # runners like group_exec.  We have the following requirements:
  #
  # 1. We need the function itself to be able to recover the `r2c` object data,
  #    which means we need to embed the actual object (not a symbol referencing
  #    it) in the function (we could alternatively use the `sys.call()` trick
  #    from `rlang` to get the attribute, but that feels like it relies on an
  #    implementation detail).
  # 2. We need the function to survive a re-loading of r2c (for safety no runner
  #    allows running r2c_fun compiled with different R/r2c versions).
  #
  # Thus, we directly embed the object with `.(.OBJ)`. We use the same trick for
  # several other objects, both directly those generated here, and also those
  # that will be generated at call time, to ensure that no run-time objects can
  # interfere with the symbol resolution of the "r2c_fun" against its
  # parameters when run stand alone.
  #
  # The .XYZ convention for these objects is decorative.  We do not rely on it
  # to avoid symbol colision with user symbols.  The embedding does that.

  # Generate the docstring that will appear at beginning of function
  .DOC <- as.call(
    list(
      as.name("{"),
      c(
        strrep("-", 60),
        paste0("| ",
          format(
            c(
              "**R2C** implementation of:", strrep(" ", 60),
              deparse(call, width.cutoff=40),
              if(check || optimized)
                c(
                  "",
                  if(check) "self-check ON",
                  if(optimized) "optimize ON (see `?get_r_code`)",
                  ""
                )
        ) ) ),
        paste0("+", strrep("-", 61))
  ) ) )
  # All required variables and meta-data; .DOC and .OBJ are embedded as
  # actual R objects, not unevaluated symbols like the rest.
  .PREAMBLE <- bquote({
    .(.DOC)
    .(.OBJ)  # for ease of access, embedded in actual fun later
    try <- tryCatch(
      .DAT0 <- as.list(environment(), all.names=TRUE), error=function(e) e
    )
    .ENV <- list2env(.DAT0, parent=envir)
    .CALL <- sys.call()
    if(inherits(try, 'simpleError'))
      stop(simpleError(conditionMessage(try), .CALL))
    # Expand dots if present
    .DAT <- if(dot.pos <- match('...', names(.DAT0), nomatch=0)) {
      dot.list <- list(...)
      names(dot.list) <- sprintf(paste0(R2C.DOTS, ".%d"), seq_along(dot.list))
      tryCatch(
        c(
          .DAT0[seq_len(dot.pos - 1L)], dot.list,
          .DAT0[seq_len(length(.DAT0) - dot.pos) + dot.pos]
        ),
        error=function(e) stop(simpleError(conditionMessage(e), .CALL))
      )
    } else .DAT0
    .FRM <- formals()
    # We don't wan to embed and actual list as that is bad for tracebacks
    .D.ENV <- list2env(.DAT, parent=emptyenv())  # enclos is not used
    .D.ENV[['.R2C.ARGS']] <- names(.DAT)         # so we can restore arg order
  })
  .EXE <- quote(
    bquote(
      one_exec_int(
       .(.OBJ), formals=.(.FRM), MoreArgsE=.(.D.ENV), call=quote(.(.CALL)))
  ) )

  # Assemble the full function, we have a normal version, and a self check
  # version that compares against normal eval.
  body(fun) <- if(!check) {  # normal
    bquote({
      .(.PREAMBLE)
      eval(.(.EXE), envir=getNamespace('r2c'))
    })
  } else {                   # self-check
    # Symbol creation is ordered so they don't interfere with symbols referenced
    # in the evaluated expressions (i.e. `call` is evaluated first when there
    # are no symbols in the r2c_fun env, .EXE doesn't resolve user symbols).
    bquote({
      .(.PREAMBLE)
      test.i <- identical(
        res0 <- evalq(.(call), envir=.ENV),
        res1 <- eval(.(.EXE), envir=getNamespace('r2c'))
      )
      test.ae <- if(!test.i) all.equal(res0, res1)
      attr(res1, 'r2c.check.identical') <- test.i
      attr(res1, 'r2c.check.all.equal') <- test.ae
      res1
    })
  }
  class(fun) <- "r2c_fun"
  fun
}


## Load a DLL and Register Finalizer to Unload It
##
## @param obj environment r2c object

load_dynlib <- function(obj) {
  handle <- obj[['handle']]
  if(is.null(handle) || !is.loaded("run", PACKAGE=handle[['name']])) {
    so.disk <- tempfile(pattern='r2c-')
    writeBin(obj[['so']], so.disk)
    obj[['handle']] <- handle <- dyn.load(so.disk)
    reg.finalizer(obj, function(obj) {
      if(obj[['handle']][['name']] %in% names(getLoadedDLLs()))
      dyn.unload(obj[['handle']][['path']])
    })
  }
  if(!is.loaded("run", PACKAGE=handle[['name']]))
    stop("Could not load native code.")
  handle
}
#' Manage `r2c` Dynamic Libraries
#'
#' List or unload `r2c` loaded dynamic libraries.  These functions are helpful
#' for managing situations where there is a sufficiently large number of `r2c`
#' functions created (hundreds) that there is a risk of exhausting the number of
#' allowed open dynamic libraries (see note for [`base::dyn.load`]).
#'
#' "r2c_fun" functions are designed to unload their associated dynamic libraries
#' when they are garbage collected, but in our experience garbage collection on
#' them is difficult to predict or force. The intended use of these function is
#' to record loaded `r2c` dynamic libraries that we wish to preserve prior
#' to creating a set that we wish to use and discard.  Once we are done with the
#' discardable set, we drop all `r2c` dynamic libraries that were not part of
#' the previously recorded list (see examples).
#'
#' `r2c` dynamic libraries are recognized solely by matching their names against
#' the regular expression pattern `"^r2c-[a-z0-9]{10}$"`.  All such libraries
#' missing from the `except` parameter will be unloaded by `unload_r2c_dynlibs`,
#' even if they were not created by `r2c`.  Any `r2c` function that has its
#' associated dynamic library unloaded will cease to work, so it only makes
#' sense to unload libraries for functions known to be deleted.
#'
#' @export
#' @seealso [r2c-compile] for details on "r2c_fun" functions, [`get_so_loc`] to
#'   retrieve original dynamic library file system location from and "r2c_fun"
#'   object, [`base::dyn.unload`], [`base::getLoadedDLLs`].
#' @param except character vector of dynamic library names as produced by
#'   `loaded_r2c_dynlibs` to exclude from unloading.
#' @examples
#' except <- loaded_r2c_dynlibs()
#' tmp.r2c.fun <- r2cq(sum(x))
#' tmp.r2c.fun(1:10)
#' rm(tmp.r2c.fun)
#' gc()                        # gc should unload lib, but it often doesn't
#' unload_r2c_dynlibs(except)  # force unload

loaded_r2c_dynlibs <- function() {
  libs <- getLoadedDLLs()
  lib.names <- names(libs)
  grep("^r2c-[a-z0-9]{10}$", lib.names, value=TRUE)
}
#' @export
#' @rdname loaded_r2c_dynlibs

unload_r2c_dynlibs <- function(except=character()) {
  libs <- getLoadedDLLs()
  r2c.libs <- loaded_r2c_dynlibs()
  libs.to.unload <- setdiff(r2c.libs, except)
  unloaded <- vapply(
    libs.to.unload,
    function(x) {
      path <- libs[[x]][['path']]
      unloaded <- try(dyn.unload(path), silent=TRUE)
      if(inherits(unloaded, "try-error")) {
        msg <- conditionMessage(attr(unloaded, 'condition'))
        paste0("Failed to unload ", x, ": ", msg)
      } else ""
    },
    ""
  )
  if(length(unloaded.libs <- unloaded[nzchar(unloaded)])) {
    if(length(unloaded.libs == 1L)) {
      stop(unloaded.libs)
    } else {
      stop(
        paste0(
          "Unable to unload 'r2c' dynamic libraries:\n",
          paste0("* ", unloaded.libs, collapse="\n")
      ) )
    }
  }
  invisible(libs.to.unload[!nzchar(unloaded)])
}
# Absolute Path for r2c Compiled Code Headers
#
# These are the headers used by code compiled by r2c, not the headers used for
# compilation of r2c proper.  We need a mechanism for specifying the absolute
# path because we could not figure out a reliable way to provide an -I include
# directory to R CMD SHLIB that would work on Windows.  We could for Mac rely on
# the `env` parameter for `system2`, but that won't work for windows.

r2c_local_headers <- function(name) {
  vetr(CHR.1)
  if(!name %in% list.files(system.file(package='r2c', 'headers')))
    stop("Header not found: ", system.file(package='r2c', 'headers', name))
  header.path <- system.file(package='r2c', 'headers', name)
  # Try to deal with spaces in header path for windows (this might have been a
  # red herring with the problem our hack attempt at using -I
  if(.Platform$OS.type == "windows")
    header.path <- utils::shortPathName(header.path)
  if(grepl(">", header.path))
    stop(
      "Header path contains '>' character which is disallowed.  You might ",
      "be able to resolve this by re-installing 'r2c' to a library path ",
      "free of that character.  Problem path:\n\n", header.path
    )

  sprintf('<%s>', header.path)
}
