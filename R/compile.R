## Copyright (C) Brodie Gaslam
##
## This file is part of "r2c - Fast Iterated Statistic Computation in R"
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 or 3 of the License.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## Go to <https://www.r-project.org/Licenses> for copies of the licenses.

## Generate a Shared Library Object From C Code
##
## @param x character the C code to compile
## @return character file name of the SO; will be in a temporary directory, it is
##   the users responsibility to preserve and/or discard the file.

make_shlib <- function(x, dir, quiet) {
  if(!is.character(x) || anyNA(x))
    stop("Argument `x` must be character and free of NAs.")

  dir.create(dir)
  file.base <- file.path(dir, sprintf('r2c-%s', rand_string(10)))
  file.src <- paste0(file.base, ".c")
  file.obj <- paste0(file.base, .Platform$dynlib.ext)
  if(file.exists(file.src))
    stop(
      "Randomly generated file name ", file.src, "' already exists. ",
      "Bad luck?  Try again."
    )
  writeLines(x, file.src)
  comp.out <- system2(
    R.home("bin/R"), c("CMD", "SHLIB", file.src),
    stdout=TRUE, stderr=TRUE
  )
  status <- attr(comp.out, 'status')
  if(!is.null(status) && status != 0)
    stop("Compilation failed with output:\n\n", paste0(comp.out, collapse="\n"))
  else if(!quiet) writeLines(comp.out)
  # is this what's returned on windows (we can specify, but should make sure if
  # the extension matters)?
  list(so=file.obj, out=comp.out)
}

rand_string <- function(len, pool=c(letters, 0:9))
  without_seed(paste0(sample(pool, len, replace=TRUE), collapse=""))

#' Compile Eligible R Calls Into Native Instructions
#'
#' The `r2c*` functions translate eligible R calls into C, compile them into
#' native instructions using `R CMD SHLIB`, and return an interface to that
#' code in the form of an "r2c_fun" function.  This function will carry out
#' out numerical calculations with `r2c` native instructions instead of with the
#' standard R routines. "r2c_fun" functions are intended to be run with the
#' `r2c` [runners] for fast iterated calculations.
#'
#' While "r2c_fun" functions can be called in the same way as normal R
#' functions, there is limited value in doing so.  "r2c_fun" functions are
#' optimized to be invoked invoked indirectly with [runners].  In many common
#' cases it is likely that using an "r2c_fun" directly instead of with a runner
#' will be slower than evaluating the corresponding R expression.
#'
#' Each of the `r2c*` functions addresses different types of input:
#'
#' * `r2cf` will generate an `r2c` version of a regular R function, provided
#'   that function uses only `r2c` supported functions.
#' * `r2cl` to turn quoted R language (e.g. as generated by [`quote`]) into an
#'   "r2c_fun" function (e.g. `r2cl(quote(a + b))`).
#' * `r2cq` to capture an unquoted R expression and turn it into an "r2c_fun"
#'   function (e.g. `r2cq(a + b)`).
#'
#' The structure of "r2c_fun" objects is subject to change without notice in
#' future `r2c` releases.  The only supported uses of them are standard
#' invocation with the `(` operator and use with `r2c` functions that accept
#' them as inputs.
#'
#' Currently the following functions are supported in `x` (or in the body of `x`
#' for `r2cf`):
#'
#' * Binary operators: `+`, `-`, `*`, `/`, and `^`.
#' * Statistics: `mean`, `sum`, `length`.
#'
#' Calls comprises must be in the form `fun(...)` or for operators `a fun b`
#' where `fun` is the unquoted name of the function (i.e.  not `"fun"(...)` or
#' many of the other variations that R will normally allow for function
#' invocation).  Functions must be bound to their original symbols for them to
#' be recognized.  Symbols used as parameters to `call` and its constituent
#' sub-calls (e.g. the `x` and `y` in `sum(x) + y`) will become parameters to
#' the "r2c_fun" function.  There must be at least one such symbol in `call`.
#' Symbol order in the "r2c_fun" parameter list is based on order of appearance
#' in the call tree after everything is [`match.call`]ed.  Symbols beginning
#' with `.R2C` are reserved for use by `r2c` and thus disallowed in `call`.
#'
#' Parameters used with "r2c_fun" supported functions are categorized into data
#' parameters and control parameters.  For example, in `sum(x, na.rm=TRUE)`, `x`
#' is considered a data parameter and `na.rm` a control parameter.  All data
#' parameters must be attribute-less numeric vectors.  Integer vectors are
#' supported, but they are coerced to numeric (and thus copied) before use.  If
#' all data inputs are integer and the R counterpart functions in `call` support
#' integer output, the result will be returned as integer by coercing (thus
#' copying) the otherwise numeric result to integer.  There are no general
#' type restrictions on control parameters, but each implemented function will
#' only accept values for them that would make sense for the R counterparts.
#'
#' In general `r2c` attempts to mimic the corresponding R function semantics to
#' the `identical` level, but there may be corner cases that differ,
#' particularly those involving missing or infinite values.
#'
#' `r2c` requires a C99 compatible implementation with floating point infinity
#' defined and the `R_xlen_t` range representable without precision loss as
#' double precision floating point.  It is unknown whether R supports C
#' implementations that fail this requirement, and if it does they are probably
#' rare.
#'
#' @export
#' @param x an object to compile into an "r2c_fun", for `r2cf` an R function, for
#'   `r2cq` an expression that will be captured unevaluated, for `r2cl` an R
#'   expression escaped with [`quote`].  See details.
#' @param formals character vector of the names of the parameters for the
#'   resulting "r2c_fun", a list of formals as generated with e.g. [`alist`], or
#'   NULL (default).  NULL causes all free symbols in `x` to become parameters
#'   to the result "r2c_fun" in the order they appear in `x`'s call tree (see
#'   details).  Non-default values can be used to specify different parameter
#'   order, and in the list form also to specify default values for parameters.
#'   Symbols in `x` not in `formals` will be resolved against the evaluation
#'   environment at run time.
#' @param dir NULL (default), or character(1L) name of a file system directory
#'   to store the shared object file in.  If NULL a temporary directory will be
#'   used. The shared object will also be loaded, and if `dir` is NULL the
#'   directory with the file will be removed after loading.  Currently the
#'   capability to re-use generated shared objects across R sessions is not
#'   formally supported, but can likely be arranged for by preserving the
#'   directory.
#' @param check TRUE or FALSE (default), if TRUE will evaluate the R expression
#'   with the input data and compare that result to the one obtained from the
#'   `r2c` C code evaluation, marking the result with attributes that indicate
#'   that the result was identical, and if not, also with an attribute with the
#'   result of an `all.equal` comparison.  The check is only carried out when an
#'   `r2c` function is invoked directly (see example).
#' @param clean TRUE or FALSE, whether to remove the `dir` folder containing the
#'   generated C code and the shared object file after the shared object is
#'   [`dyn.load`]ed.  Normally this is an auto-generated temporary folder.  This
#'   will only delete folders that have the same directory root as one generated
#'   by `tempfile()` to avoid accidents.  If you manually provide `dir` you will
#'   need to manually delete the directory yourself.
#' @param quiet whether to suppress the compilation output.
#' @param TRUE, FALSE, or an integer setting optimization levels.  Currently
#'   applies [`reuse_calls`] if not FALSE or 0.
#' @return an "r2c_fun" function; this is an unusual function so please see
#'   details.
#' @name r2c-compile
#' @aliases r2cf
#' @seealso [`runners`] to iterate "r2c_fun" functions on varying data,
#'   [`get_c_code`] for functions to retrieve meta data from the function,
#'   including the generated C code and the compiler output.
#' @examples
#' r2c_sum_sub <- r2cq(sum(x - y))
#' r2c_sum_sub <- r2cl(quote(sum(x - y)))  ## equivalently
#' sum_sub <- function(x, y) sum(x - y)
#' r2c_sum_sub <- r2cf(sum_sub)           ## equivalently
#' r2c_sum_sub(-1, c(1, 2, 3))
#'
#' ## Set parameter order for r2cq
#' r2c_sum_sub2 <- r2cq(sum(x - y), formals=c('y', 'x'))
#' r2c_sum_sub2(-1, c(1, 2, 3))
#'
#' ## Leave symbols unbound
#' y <- 10
#' r2c_sum_sub(x=3)
#'
#' ##  Make a version that is checked
#' r2c_sum_check <- r2cq(sum(x), check=TRUE)
#'
#' ## Checks are disabled when using runners
#' r2c_sum_check(1:10)                                 # checked
#' group_exec(r2c_sum_check, 1:10, groups=rep(1L, 10)) # not checked

r2cf <- function(
  x, dir=NULL, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE), clean=is.null(dir),
  optimize=getOption('r2c.optimize', TRUE)
)
  r2c_core(
    body(x), formals=as.list(formals(x)),
    dir=dir, check=check, quiet=quiet, clean=clean, optimize=optimize
  )

#' @export
#' @rdname r2c-compile

r2cl <- function(
  x, formals=NULL, dir=NULL, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE), clean=is.null(dir),
  optimize=getOption('r2c.optimize', TRUE)
)
  r2c_core(
    x, formals=formals, dir=dir, check=check, quiet=quiet,
    clean=clean, optimize=optimize
  )

#' @export
#' @rdname r2c-compile

r2cq <- function(
  x, formals=NULL, dir=NULL, check=getOption('r2c.check.result', FALSE),
  quiet=getOption('r2c.quiet', TRUE), clean=is.null(dir),
  optimize=getOption('r2c.optimize', TRUE)
)
  r2c_core(
    substitute(x), formals=formals, dir=dir, check=check, quiet=quiet,
    clean=clean, optimize=optimize
  )


r2c_core <- function(call, formals, dir, check, quiet, clean, optimize) {
  vetr(
    is.language(.), (list() && !is.null(names(.))) || NULL || CHR,
    dir=CHR.1 || NULL, check=LGL.1, quiet=LGL.1, clean=LGL.1,
    optimize=LGL.1 || INT.1.POS
  )
  auto.formals <- FALSE
  if(is.character(formals)) {
    frm.names <- formals
    formals <- replicate(length(formals), alist(a=))
    names(formals) <- frm.names
  } else if(is.null(formals)) {
    auto.formals <- TRUE
    formals <- list()
    names(formals) <- character()
  }
  # Parse R expression and Generate the C code
  preproc <- preprocess(call, formals=names(formals), optimize=optimize)

  # Generate directory, use dirname/basename to normalize it to same format as
  # file.path
  if(is.null(dir)) dir <- tempfile()
  dir <- file.path(dirname(dir), basename(dir))

  # Compile C code
  so <- make_shlib(preproc[['code']], dir=dir, quiet=quiet)
  # Pre-load lib as by default we don't keep the SO file
  handle <- dyn.load(so[['so']])
  if(clean) {
    so[['so']] <- NA_character_
    unlink(dir, recursive=TRUE)
  }
  # But if we do keep it, we want to be able to recover it later.  We store the
  # data in an environment for deparse into <environment> instead of a list.
  OBJ <- list2env(
    list(
      preproc=preproc, so=so[['so']], handle=handle,
      call=call, compile.out=so[['out']]
    ),
    parent=emptyenv()
  )
  # Generate formals that match the free symbols in the call
  if(auto.formals) {
    sym.free <- preproc[['sym.free']]
    # Anything bad happen if we allow the below through?
    if(!length(sym.free))
      stop(
        "Expression `", deparse(call), "` does not contain any parameter symbols."
      )
    formals <- replicate(length(sym.free), alist(a=))
    names(formals) <- sym.free
  }
  fun <- fun.dummy <- function() NULL
  formals(fun) <- formals
  environment(fun) <- .BaseNamespaceEnv

  # The generated function needs to be be callable stand-alone, and useable by
  # runners like group_exec.  We have the following requirements:
  #
  # 1. We need the function itself to be able to recover the `r2c` object data,
  #    which means we need to embed the actual object (not a symbol referencing
  #    it) in the function (we could alternatively use the `sys.call()` trick
  #    from `rlang` to get the attribute, but that feels like it relies on an
  #    implementation detail).
  # 2. We need the function to survive a re-loading of r2c (but we probably
  #    shouldn't allow it to survive across different versions)
  #
  # Thus, we directly embed the object with `.(OBJ)`, and we make the enclosure
  # of the function the base environment.  We use the same trick for several
  # other objects, both directly those generated here, and also those that will
  # be generated at call time, to ensure that no run-time objects can interfere
  # with the symbol resolution of the "r2c_fun" against its parameters.

  # Generate the docstring that will appear at beginning of function
  DOC <- as.call(
    list(
      as.name("{"),
      c(
        strrep("-", 60),
        paste0("| ",
          format(
            c(
              "**R2C** implementation of:", strrep(" ", 60),
              deparse(call, width.cutoff=40),
              if(check) c("", "self-check ON", "")
        ) ) ),
        paste0("+", strrep("-", 61))
  ) ) )
  # See below, we can't do this inline as it would be nested bquote
  FORCE <- quote(eval(bquote(list(.(as.name(i))))))
  # All required variables and meta-data; DOC and OBJ are embedded as
  # actual R objects, not unevaluated symbols like the rest.
  PREAMBLE <- bquote({
    .(DOC)
    .(OBJ)  # for ease of access, embedded in actual fun later
    try <- tryCatch(
      .DAT <- as.list(environment(), all.names=TRUE), error=function(e) e
    )
    .CALL <- sys.call()
    if(inherits(try, 'simpleError'))
      stop(simpleError(conditionMessage(try), .CALL))
    if(dot.pos <- match('...', names(.DAT), nomatch=0))
      tryCatch(
        .DAT <- c(
          .DAT[seq_len(dot.pos - 1L)], list(...),
          .DAT[seq_len(length(.DAT) - dot.pos) + dot.pos]
        ),
        error=function(e) stop(simpleError(conditionMessage(e), .CALL))
      )
    .DGRP <- if(length(.DAT)) .DAT[1L] else list()
    .FRM <- formals()
    .ENV <- parent.frame()
  })
  # We'll use group_exec with a single group to act as the runner for the
  # stand-alone use of this function, so ue `groups=NULL`.
  GEXE <- quote(
    bquote(
      group_exec_int(
        NULL, formals=.(.FRM), enclos=.(.ENV), groups=NULL,
        # Pretend first argument is group-varying, even though it's not
        data=.(.DGRP), MoreArgs=.(.DAT[-1L]), call=quote(.(.CALL))
  ) ) )
  GEXE[[c(2L, 2L)]] <- OBJ  # embed object directly in call (replaces 1st NULL)

  # Assemble the full function, we have a normal version, and a self check
  # version that compares against normal eval.
  body(fun) <- if(!check) {
    bquote({
      .(PREAMBLE)
      eval(.(GEXE), envir=getNamespace('r2c'))
    })
  } else {
    # Symbol creation is order so that no created symbols will interfere with
    # symbols referenced in the evaluated expressions.
    bquote({
      .(PREAMBLE)
      test.i <- identical(
        res0 <- eval(.(call), envir=.ENV),
        res1 <- eval(.(GEXE), envir=getNamespace('r2c'))
      )
      test.ae <- if(!test.i) all.equal(res0, res1)
      attr(res1, 'r2c.check.identical') <- test.i
      attr(res1, 'r2c.check.all.equal') <- test.ae
      res1
    })
  }
  class(fun) <- "r2c_fun"
  fun
}

#' Extract Data from "r2c_fun" Objects
#'
#' "r2c_fun" functions contain embedded data used by the runners to call the
#' compiled native code associated with the functions.  The `get_*` functions
#' documented here extract various aspects of this data.
#'
#' * `get_so_loc` the file system location of the shared object file.
#' * `get_c_code` the generated C code used to produce the shared object.
#' * `get_r_code` the R call that was translated into the C code.
#' * `get_compile_out` the "stdout" produced during the compilation of the
#'   shared object.
#' * `show_c_code` retrieves code with `get_c_code` and outputs to screen the
#'   portion corresponding to the compiled expression, or optionally all of it.
#'
#' @rdname get_r2c_data
#' @aliases get_c_code get_r_code
#' @seealso [`r2c`].
#' @export
#' @param r2c.fun an "r2c_fun" function as generated by e.g. [`r2c`].
#' @param all TRUE or FALSE whether to retrieve all of the C code, or just
#'   the portion directly corresponding to the primary runner function.
#' @return for `get_r_code` the R language object the C code is based on,
#'   otherwise a character vector, invisibly for `show_c_code`.
#' @examples
#' r2c_sum_sub <- r2cq(sum(x + y))
#' get_r_code(r2c_sum_sub)
#' show_c_code(r2c_sum_sub)

get_c_code <- function(r2c.fun, all=TRUE) {
  vetr(all=LGL.1)
  code <- get_r2c_dat(r2c.fun)[['preproc']][['code']]
  if(!all) {
    start <- grep('^void run\\($')
    if(length(start) != 1L) stop("Could not detect runner function.")
    code <- code[seq(start, length(code))]
  }
  code
}

#' @export
#' @rdname get_r2c_data

get_r_code <- function(r2c.fun) get_r2c_dat(r2c.fun)[['call']]

#' @export
#' @rdname get_r2c_data

get_so_loc <- function(r2c.fun) get_r2c_dat(r2c.fun)[['so']]

#' @export
#' @rdname get_r2c_data

get_compile_out <- function(r2c.fun) get_r2c_dat(r2c.fun)[['compile.out']]

#' @export
#' @rdname get_r2c_data

show_c_code <- function(r2c.fun, all=FALSE) {
  vetr(all=LGL.1)
  code <- get_c_code(r2c.fun, all=all)
  writeLines(code)
  invisible(code)
}

get_r2c_dat <- function(r2c.fun) {
  if(!is.function(r2c.fun) || !inherits(r2c.fun, "r2c_fun"))
    stop("`r2c.fun` must be an r2c function.")
  dat <- try(body(r2c.fun)[[c(2L,3L)]])
  if(inherits(try, "try-error"))
    stop("`r2c.fun` does not appear to be structured like an r2c function.")
  if(!is.environment(dat))
    stop("Could not find data environment in `r2c.fun`")

  dat <- as.list(dat)
  if(!all(c('preproc', 'call', 'so', 'compile.out') %in% names(dat)))
    stop("`r2c.fun` missing some expected components.")

  dat
}

