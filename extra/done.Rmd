## Won't Do

* Should we add `rm` statements (optionally) for `reuse_calls` use in R (not in
  `r2c` as there we track lifetime, and none of the allocations can be released
  until the end) to reduce peak memory usage?  Doesn't seem worth it.

* Cleanup `code_gen_x`.  A lot of things should be parametrized so that we're
  consistent across `code_gen` functions.  This is going to be complicated to do
  flexibly enough.  Definitely can be done but will be annoying.

## Done

### v0.4.0

* Defer creation of temporary vectors until end (just record their size) so that
  we don't allocate vectors we don't use.  We should also identify unused
  vectors and not allocate them (e.g. because branch reconciliation made a
  vector unused - does this actually happen)?

* Check what the `ARGS.NM.VAR` variable is, is it the total number of arguments,
  or the total number of `...` arguments.  Important to get this right for the
  summary functions.  So the `*narg` array has one entry per (sub-)call, and
  each entry is an integer that reflects the number of `id` values minus one
  for the result.  So it is the total internal arg count.

* Add a finalizer to unload and dump dlls (but in some OSes we cannot unload
  DLLs, so maybe need a mechanism for generating libraries).:

    qz1ylj3zna.so':
      `maximal number of DLLs reached...

  See notes.Rmd for additional discussion.


* Default arguments in `group_exec` don't seem to work (test with `r2cf`)?
* Default arguments that depend on iteration varying data (i.e. the default
  references an argument that is iteration varying); probably just don't support
  this type of function?

    f1a <- r2cf(
      function(x, na.rm=TRUE) sum(x, na.rm=na.rm)
    )
    args(f1a)
    ## function (x, na.rm = TRUE)
    ## NULL
    group_exec(f1a, 1:4, rep(1:2, 2))
    ## Error in sum(... = x, ... = na.rm, na.rm = FALSE) :
    ##   object 'na.rm' not found
    f1a(1:2)
    ## [1] 4   # <---- WRONG, adding the na.rm value

* Function with default formals in `group_exec`.

* Do we need to check for integers larger than 2^53 for loss of precision?  Is
  that even possible?  R semi guarantees 32 bit integers.  What if double was 32
  bits?  Probably do need a similar assumption check.

* Clearly document `ftype[[3L]]` function format.

* Why do we lose a local assignment from `data[[B.NAMED]]` from branch rec?  Not
  entirely.  Update: No idea what this was about.  Oh well.

* Rename `rec` `brec` to distinguish more clearly from `lrec`?
  Should `lrec` be `lcopy` since it actually copies more so than reconciles?  In
  fact there is no loop reconciliation per se, just a runtime directive to copy.
  We renamed `lrec` to `bcopy`.

* Make sure that the result slot is compatible with the `asize`.  When we remap
  an allocation to the result, it can only be the instance that will be written
  to the result itself.  This is particularly the case if intermediate results
  use that slot.
* Make sure that when we reconcile sizes we account for the size of the
  allocation, not just the size of the objects being reconciled.  Otherwise when
  we repoint everything some of the interim stuff might not fit anymore.  This
  probably hasn't been an issue so far because we cause all reconciliation to be
  branch-local memory allocations, but I think the problem can still happen.
  The size should be max of existing asize and what we need, in addition to
  ensuring that the two objects being reconciled have the same size expression.
  **UPDATE**: maybe this doesn't matter so long as when we reconcile, we
  generate an entirely new allocation that isn't shared with anything else?
  Confirm it is actually entirely new and not a potential re-use of a freed one!
* It could matter given we could use branch-local allocations.  So instead we
  just disallow re-use for reconciled values and so on.

* Big `group_exec` involving branches.

* Loops with no iterations (definitely tested).

* Are we robust to zero result sizes?  Particularly when not all results are
  size zero.  Is it possible to have varying number of zero length results
  (probably not)?  We seem to be.

* Recompose control for for loops.

* What happens if we try to return/reconcile the iteration variable (`i` in
  `for(i in ...)`?  Either from the loop, or the loop nested inside an if/else.
  This works, but highlighted that we need to vcopy literals too.

* Why do we not need to worry about sub-assign in loops?  Is it because we
  already directly modify in memory, and we don't allow use of return value?
* What happens when we subassign in a branch?  This should be handled?  It seems
  like it doesn't matter because we are not changing the size of the variable so
  subsequent code is unaffected.

* Not clear that constants are being handled properly (e.g. need to `en_vcopy`
  the constant in `transform_control` for `for_init`).

* Need to make sure that alloc doesn't release `for` bindings until end of loop.
  We do check for it by getting all the symbols in a `for` call in the
  linearized call list (which will be after all the loop calls), but big problem
  there is we're using the original loop names, not the preprocessed ones.
  Need to add a test that confirms this works.  We changed
  `collect_loop_call_symbols` to look at `for_n`.

* Rationalize documentation of "implementation detail" functions like `r2c_if`
  and `subassign`.  Maybe hide them from the index with `@keywords internal` and
  add a family that connects them.
* Make sure to explain how we generate the C code for control structures as that
  is not at all obvious.  Currently docs are spread in `?r2c_if` and in
  `transform_control`.

* What happens when we use the counter from a loop either outside of the loop as
  part of a use before set?  It should be reset at beginning of loop each time?
  So shouldn't matter.  If we read from it it's set.  If we write to it it was
  already set beforehand.

* It would be nice to be able to assume there are no nested braces ever in
  "preproc-copy.R".  Alternatively (now more likely I think), ensure that
  anyplace that isn't robust to nested braces tests for them.  We apply
  `collapse_braces` now (and I think otherwise error when this happens).

* Assignment chains should contain only `ASSIGN.SYM`, and possibly only
  `ASSIGN.SYM.BASE`.  We can't have stuff like `a <- {b} <- c`

* Make sure that a user can't try to sneak in e.g. `lrec`.

* Test use before set where multiple symbols are set to the same value?

* Identify external only expressions and eval them just once?
* What do we do about repeated external symbols getting added to the allocation
  table?  See notes "External Symbols".
* Reconcile binding of group names and assignment names?  A bit awkward now in
  `append_dat`.  What about `MoreArgs` names (these are treated as external
  symbols, stored in an env ahead of the parent env)?
* Check that we don't lose "shallow copy" of external vectors.

* `for` is documented to always return NULL, but also to set `var` to NULL if
  there are no iterations (need to figure out what we do with this; set to
  NaN?).  Set to NaN

* r2c.for example clearly broken.

* Fill out `for` stub functions.

* Thank Yihui for formatR.  Actually, it doesn't really do what I thought it did
  so we're not using it anymore.

* Ensure that use before set, but then use copy after set also works (i.e. we
  if we aliased the use before set symbol before setting, that the alias is
  is not overwritten when we reconcile).

* Now that we dropped `luse`, see if we can drop the "sketchy" logic we added to
  register external symbols as names.

* Document for:
  * Limit to number of for loops. - done.
  * Limit for parameter size permutations. - done.

* Whitespace not great for generated C code for loops.  Meh, it's okay.

* Braces not getting fully collapsed anymore after processing for `for`.  We
  added a brace collapse pass after initial preprocessing.

* Make sure we can't overflow `R_xlen_t` with `seq.i` in `for`.  We can't,
  `seq.i` is checked against a value from `lens[]`, which is `R_xlen_t*`.

* Check that we can't do stuff like `for(a + 2 in ...)` (i.e. symbol must be
  target).  This is actually a parse error.

* Is the new use of `in.branch` with the index a good way to deal with
  `sym.local` (i.e do we need both)?  Yes, it is.  But can't get rid of B.LOC or
  sym.local computed without further analysis.  Would be nice to be able to make
  the computed thing a property of the candidate, but not entirely sure it can
  be.

* Seeing weird reconcile / vcopy of iteration variable with nested loops.  One
  weirdness is that the "assign" from `for_iter` has two payloads (the latter we
  just added a comment for).

    // r2c::for_iter(var = j, seq = .R2C_for_seq_2, seq.i = r2c::rec(x = r2c::vcopy(x = .R2C_for_seqi_2)))


* Make sure `reconcile_control_flow` works correctly for for loops.

* Do we disallow using group vectors as control variables?  Probably makes sense
  to do this.  Very confusing / weird otherwise, straight up error message
  better.  I'm not sure there is a use case that makes sense.  Also need to
  resolve the complexity of an external variable getting masked by a binding.
  This should just be disallowed.  Need to consider the case where control
  parameters include expressions.  Do we just defer evaluation on those?  How
  complex an expression do we allow?  Do we allow binding symbols in them?
  It is now an error to attempt to use these in external expressions.

* Think through implications of `x <- numeric(n)`, any problems with
  re-allocation vs just rewriting with zeros?  Should be okay, but we do need to
  rewrite with zeros every iteration.

* Resolve confusing naming around control parameters and control flow
  structures.


* Simplify flags to make them part of the data array?  This would remove one
  parameter from parameter list since we're already squeezed there.  Something
  to think about, could be nice.  Then numeric external and flag external can
  have the same logic.  Implementation can still use "bitwise" comparison on the
  double values and now can go up to 2^53 (but is this slow?).  Looks like this
  would require coercion.  They are now just members of the array represented as
  doubles.  No longer flags.
* Rename control parameter to external parameter so that e.g. `numeric(x)` makes
  sense.  Done.

* What's up with the `args.ctrl`, `args.flags`, etc in the code gen functions
  where we don't seem to use those anywhere?  Not relevant anymore.

* For control / flag parameters, do we evaluate sub-expressions?  No, we
  evaluate the whole thing without recursion.

*  Does preproc-copy actually fully detect whether a branch return value is
  used?  Yes, it does seem so.

* Go through all the cgen functions and make sure they are okay with the changes
  in flag, etc.

* Make sure that parameter type matching doesn't get confused between internal
  and external when `...` matches to both e.g. `r2cq(sum(x, y, na.rm=TRUE))`.
  Actually, should never be the case that `...` is an external parameter so it
  shouldn't matter.

* Do `for` and `while` need to be decomposed?  Yes.

* Remove old reference to `i` from `names_update`.

* Why did we move the self-copy for sub-assign into ext to the very beginning of
  the call?  Probably nested branches with sub-assigns?  Problem is this causes
  more than one copy as next.  If we had deferred the copy to be in-branch the
  return value copy would not be necessary.  Gaah, it's because we don't want to
  vcopy every loop iteration, and particularly with nested loops, we really want
  the copy to be done outside of every loop.  It ends up looking messy but the
  flipside is you avoid needless copies since we just want one copy to ensure
  not external.

    x <- r2c::vcopy(x)
    if (a) {
        s <- mean(y)
        x[a] <- s
        r2c::rec(r2c::vcopy(x))
    }
    else r2c::rec(y <- x + 1)

  Additionally, copying in a loop is always just going to reset to the original
  values since the second time the loop goes around it's still referencing the
  old value that was copied.

* The `x <- vcopy(x)` issue in a loop where we then sub-assign to `x`, but the
  second (and n) times around all our modifications are overwritten because the
  two `x`s in the self copy are actually different memory locations.

* Do we need `if_true` / `if_false`?  Effectively implicit in position, but
  might simplify finding boundaries (actually, definitely does).

* Loop counter variable not being recognized as assigned-to.

* Zero length return value does not retain correct type (this was specific to
  subset bug).

* Think carefully about the following case.  Can we get away without a
  reconciliation (as it is it's just not right - mismatched rec).  This is now
  resolved by moving the vcopy outside of the branch.

  {
      x <- r2c::vcopy(x)
      if (b) 
          x[a] <- y
      else {
          x <- r2c::rec(r2c::vcopy(x))
          numeric(0)
      }
      x
  }

* Sub-assignment from a complex expressions that strains eval order.  How do we
  recognize that `x` is not external because we'll be vcopying it?  Is this even
  allowed (assign inside arg)?  Do we need to vcopy `x` in this case (no).  We
  should see this because we process the arg first.

    x[a] <- {
      x <- y + 1
      y
    }

  Maybe more relevant:

    if(b) {
      x[a] <- x
      x
    }

  Seems like we can't get in a situation where we don't recognize the symbol is
  local.

* Can we collapse the subassign into regular promotes now that we're
  rationalizing the 0 (i.e. get rid of `add_actual_sub_callptr` (or whatever
  it's called).  Yes, done.
* Make sure that we deduplicate `rec` and `vcopy` requirements e.g. for the case
  of sub-assignment (maybe this is untestable because we don't allow the result
  of a sub-assignment to be used?).  Does't seem an issue now?
* Check it's okay to add curly braces for the sub-assign to ext copy.  Do we
  need to collapse nested `{` later?  We do collapse the braces.
* `clean_call` should deal with `subassign`.
* Actual run time sub-assignments.
* Subassign inside if/else.
* Subassign assign to self `x[a] <- x` (we do need to pass through the
  subassign as `prev.call`?).
* Attempt to use `subassign` directly.
* Subassign on a symbol that has a candidate bound, should trigger.
* Subassign on an external symbol in one branch creates a candidate in the
  other (because it needs to be reconciled).

* Unary plus:
  * Executes vcopy correctly when needed
  * Coerces logical to integer

* Double check that the re-use optimization doesn't attempt to re-use an
  expression computed only in one branch.  Or maybe if there are two if/else's,
  each with the expression in one branch, how does it treat that?  I think we
  fixed this by hoisting?

* Reconcile needs to functionalize all the code that is running on the `T` and
  `F` in "parallel".  So long as the intermediate results aren't used later we
  should be able to do it.

* Do we allow if's nested inside arguments (probably yes)?  If we do, what
  happens to assignments within the if branches (probably disallow these)?  We
  disallow these.

* Prevent users from using `r2c::if_test` and related functions directly.  They
  may only appear in a very specific order.  How do we disallow them?  Not sure
  if we want to disallow them.
* Check that user doesn't introduce their own `vcopy`'s.

* Make sure braces are only nested in braces (except for the special case of the
  `if/else` / `loop` functions).  This is to prevent people bypassing the
  prohibition against assigning within arguments by throwing a brace expression
  in an argument.

* Are `A && B` and `A || B` actually lazy?  Probably not given the linearization
  that evaluates each argument before the result?  We could consider translating
  the above into `if(A) B else FALSE` and `if(A) TRUE else B` once `if` is
  implemented (need to think about preserve logical for these cases).  We just
  documented these as not lazy.


* Symbol expiration logic in `alloc` might not work well with branches.  Eh, no,
  it's okay because it is conservative and looks for the very last instance of
  the symbol used as a leaf.

* Could reconciliation use a previously allocated but freed vector as the target
  to put reconciliation in?  Need to make absolutely sure it e.g. is not used in
  the TRUE branch, so maybe not?  Feels a bit dangerous.  No, let's not to this.

* `if` without `else`:
  * Also cases where all `if` written symbols pre-exist, and where some don't.

* Check that a non-local symbol inside an active expression doesn't get copied
  just by virtue of being last in a computing function that takes such symbol
  last (e.g. `mean` doesn't because of `na.rm`, etc., can use `-`).

* Add multi-assign test for branch result.

* See if it is easy to implement that returning a computed global symbol from a
  branch doesn't require copy if the symbol isn't used again elsewhere.  See
  `call3b`.

* is `r2c_if` really passive?  No, the result will be computed if it is used.

* New return value cases to handle in branches:
  * If it is a local binding from a computation, do we need to vcopy?  Maybe
    not?  No, we don't need to copy it.  The problem is when the binding is
    non-local.  So we make a candidate on that binding.  If that binding is
    used, then it will be vcopied.  Otherwise we can just use it directly as the
    return value.
  * If it is a non-local biding it needs to be copied if the return value is
    used (last part could potentially be handled by dead code removal).
  * It is a computing expression.
    * Nothing, we can reconcile directly.
  * A binding expression?
    * Same as a local binding, but for the whole expression.  So we add
      candidates for the entire `assign.to` in the binding chain?  Basically,
      same behavior as normal, except that we require candidacy even when the
      thing being bound is a computing expression.  So we need a modification on
      the `last` flag which is when the expression is returned.
  * A passive expression, presumably depends on what it contains.

  * It is a maybe non-local binding, an assignment expression, or a passive
    expression returning .
    * If `if` inside a computing call, assignment, or if it is returned, vcopy
      it (possibly again).
  * It is a binding expression.
    * `vcopy` the whole thing.
  * It is a passive expression.

* Make sure branches work well with multiple symbol assigned to same slot (`x <-
  y <- z`).

* Implement "eqlen" r2c token type (for e.g. `r2c_if`).

* Undo the `if/else` conversion for display in `get_r_code`.



### v0.3.0

* Switch `noop` to be flags the control whether the call is issued, whether the
  deparsed R call is issued, and whether the definition is issued.  And document
  it all. Probably should be done through code_res.
* Does `record_call_dat` really need to record terminals?  Main thing that is
  done is dealing with `..1` etc, but where do we use that?  Update: of course
  we do, as we still have to evaluate them / match them to an allocation in the
  allocation step.
* Remember why we don't increment `*flag` inside the function call?  Is it just
  because it's not always used and easier to do it outside?
* Check that the interrupts work when there are more than 1e7 elements in a
  group / window.
* Test that unary plus:
  * Executes vcopy correctly when needed
  * Coerces logical to integer
* Any / All accept dots as arguments.
* Check NA behavior on logical and relational operators, and switch to use e.g.
  `islessequal`, etc. (and how do we test equality/non-equality efficiently)?
* Interrupts:
  * Need to implement for per iteration check for:
    * process groups (done)
    * check performance degradation (done, none)
    * test interrupts every 1MM instead of every 10MM? (didn't bother)
  * Document / provide capability to of re-enabling the LOOP_W_INTERRUPT
    business? (kind of of done in ?r2cq)
  * See if we can get instruments to work on x86 to better understand what the
    problem actually is (it did work on sum_add, but not on the dynamically
    loaded versions that just gave a call references to rbp -x40 or some such,
    wasn't obvious what was slow)?
* Handle cases where package environment is captured by unitizer (see notes,
  "Package Env") (fixed in unitizer 1.4.19).

### v0.0.0-0.2.0

* Support for functions with defaults that need to be evaluated?  No.  This
  substantially increases complexity because we have to do so in the function
  evaluation environment and need access to all the other arguments.  We could
  potentially support things like `quantile(..., seq(0, 1, .25))`.
* Side effects from evaluation of control parameters?  Where should assigned
  variables reside?  Update: we won't support non-literal (or limited anyway)
  control parameters.
* Make `fun` vs `r2c.fun` consistent across runners and compilation funs?
* Look into the big unitizers. "big.R" likely needs to be a regular test file,
  not a unitizer one.  Also some of the other files are a bit big.  Some of the
  other files got big without even any of tests changing (e.g. summary.R was not
  modified, but the test file grew from 21K to 61K).  We dealt with big.  The
  other ones are mostly a `unitizer` issue.
* Add a cleanup pass for `get_r_code` (and document that's being done).  Drop
  `...` in names, and maybe default args that are set to their default values.
  Harder but potentially useful is any arguments that are in the same order they
  were originally.  Maybe use something other than `.R2C_SUB_` as root.
* try overriding `::` to check that errors correctly.
* Is it okay for `square` to require `r2c` attached?  Inconsistent with what we
  do with `r2c_copy`.  A possible solution would be to implement `::`.  Then we
  could rename `r2c_copy` to `copy` or `copy_vec` (later to reduce collision
  with e.g. `data.table`).
* Make sure we think through the interaction of things with `sym.free` with
  variable assignment as that could cause problems since that assumed the only
  source of them was parameters.  Seems okay.
* Does preproc `sym.free` `sym.bound` make sense now with `formals` supplied?  I
  think so since it's still possible to do pass a language object.
* Do we need `id` if it's always just `seq_along(id)`.  Probably not, `id0`
  should be sufficient.  We don't need it, dropped.
* Document side effects in external parameters?
* Transform should be an optimization or processing?  It would make sense for it
  to show up in the `$processed` member.
* Read through all comments and make sure they are up to date.
* Do we still use the 'assign' field in `record_call_dat`?  If not, excise.  We
  do use it to allow us to putty dummy calls on the stack.
* Check that forwarding calls in `...` works correctly, e.g.
  `sum(1 + x, 2 + y)`, not obvious from glancing at dots handling that it does.
  Update: not clear what we though the issue was, seems to work fine?
* Symbol resolution apparently skips non-naked data; does that make sense or
  should it find it and error?  No, it doesn't, it looks through all the data.
* Check into why compilation output is incomplete (try borking one of the
  C functions, looks like only some of the output makes it out right now
  compared to actually running the compilation command).
* Make sure that the Function Environment in `r2cf` is captured somewhere.  In
  particular we want to make sure unbound symbols are resolved according to that
  environment.  Will also need to think about what this means for the `enclos`
  parameter to the runners.  
* `r2cq(test)` produces weird error (note that's just a symbol) (fixed).
* Make sure that the no-op C functions don't return warnings.
* Test corner cases such as a repeated assignment to see if it get correctly
  detected as being repeated.
* Test `reuse_call` with empty call.  Seems to work fine.
* Calling `r2c_funs` without `r2c` loaded, in particular when we're using `r2c`
  functions such as `r2c_copy` or `mean1`?  Should be okay, it should fail?  It
  does, just need to deal with `r2c_copy`.  Just ended up waiving the lookup
  check for `r2c_copy`.
* Reuse with an inner expression that appears separately from a re-used outer
  expression (yes, `r2c_int` is a good example of this working).
* Final call is not a computation, will things work okay?  They do now.
* Test empty braces (`{}`). We disallow.
* What happens if we have an assignment at depth 0?  Nothing much, works as
  expected.
* Are we okay with doing the call substitution before match-calling?  That's
  going to change param evaluation order.  Probably not okay.  Is that what
  we're doing though?  We disallowed expressions containing non top-level
  assignments.
* Renames:
  * Don't change the structure of the tree
  * Can be reversed (maybe this covers the prior point)
* Add tests that confirm us overriding functions used by the "r2c_fun" does not
  break anything.
* Do we want to hoist out temporary code-reuses to the top level so that we can
  enforce evaluation order, and also to try to make the code clearer?  Main
  challenge is if there is an assignment at some point earlier in the expression
  that conflicts with the hoisting (i.e. hoisting would result in the expression
  referencing an undefined symbol).  And what does top-level mean when e.g.
  there is a loop or branch (do we go all the way, or stop there)?
* Assignment isn't re-using last available slot.  It should if it's unprotected.
  Maybe it could under additional circumstances?
* Can we optimize away `braces`?  They don't really do anything but return the
  last value, which is what would happen anyway.  Maybe too annoying to deal
  with in the current structure.  Another problem with braces is that they cause
  everything under them to be protected by depth by virtue of being siblings,
  when really we only care about the last value.
* Test renames with potentially ambiguous names (too long for root, special
  symbols).
* Fix over-optimization where expression that is already assigned to a symbol
  gets assigned to a sub-symbol.  This is not trivial because we need to
  identify that an expression already has a name, etc., etc..  This is really
  not a big deal so we'll leave it alone.  Here is an example.

    reuse_calls(quote({a <- mean(x); mean(x)}))
    ## {
    ##     .R2C_SUB_1 <- mean(x)
    ##     a <- .R2C_SUB_1
    ##     .R2C_SUB_1
    ## }

* Disallow any optimization when there are assignments not at a brace level?
  But even then the code evaluation is questionable.  We should probably just
  disallow it altogether, as in `r2c` simply does not accept parameters with
  side effects (need to think about controls, flags).
* Make sure we understand when it's okay or not okay to assume about order of
  evaluation of parameters (e.g. when they contain assignments in them).
  Probably we'll just have to document that what we assume may be different than
  what R does, and it's a really bad idea to do this in the first place in a way
  where order matters. (we decided to just disallow this).
* Rename `r2c` to `r2cf` or similar once we implement functions.  Partly this is
  so `?r2c` will pull up the package docs, not the function docs.
* To allow assignments we can just use a series of nested environments such that
  each sub-call will then seek the symbol through the nested environments.
  We'll need to bind the data symbols to e.g. environments so they may be
  uniquely identified and we can confirm they've been found.  Err, what were we
  thinking here?
* Complex expressions with curly braces, etc.
* Consider giving each individual allocation a unique id, and putting those ids
  in the stack, that way when there is a stack reduce we can confirm that the
  allocation slots being pointed to actually contain the data intended (this is
  to help detect errors in the code that might otherwise result in corrupted
  data).
* Figure out why single group eval so much slower for `group_exec` (see notes).
* Change reserved symbols to be anything starting with `.R2C` so we have more
  flexibility and don't need to use the same format for dot args, replaced
  names, etc.
* `reuse_call` and `rename_call` need to realize that for loops assign values!
  It should be okay to just rename the counter; I think everything else works
  out.
* Currently we require at least one data column so we can get away with using
  the group logic for the stand alone evaluation of the r2c funs.
* Error case where the matching doesn't work and data or MoreArgs is e.g. a
  variable or a complex expression.
* Test that everything works if there is no group varying data (i.e. everything
  fed through MoreArgs).  Not completely trivial to test as we need a function
  that allows us to specify a `data` parameter, but then uses it as a control
  instead of data (at least for `group_exec`).  We just need the group varying
  data to be referenced somewhere in the call, which ...
* Test:
  * Zero element data and non-zero row groups
  * Zero element data and zero row groups
  * No iteration varying data at all
  * Windows, in particular should still be possible with things that specify
    position.
* Doc page for "runner" functions.
* UBSAN / valgrind, and more.
* Installation instructions?
* Remove benchmarks from `roll*_exec` docs.
* Suppress compiler version output from R CMD SHLIB, check that compile error
  handling is okay.
* Make `group_exec` interface consistent with `roll*_exec`
* Numeric group vectors provoke weird error from `group_exec`
* Acknowledge that runner also uses `at` (but I think this was independent).
  Decided against, it really was independent I think and it's pretty trivial.
* Recycle warning for windows, does it make sense?  It might with the partial
  windows, but for the main section we should only need to check once?  This is
  actually significant for the `w=1` case, taking about 40% of the time the
  function evaluation takes (`r2c_sum`).  But probably in the noise for all
  other cases.  Similarly, can we get away with not checking return length?
  Implicitly we probably don't for group functions, so maybe we don't have to?
  IIRC we settled on whatever we do ATM.
* Should `x` be `x` or `pos`?  `x` feels most correct, but also confusing
  because of the use of `x` as a data variable.
* Figure out segfault in slope window case.
* Add big tests including the one causing the segfault.  Come up with a more
  complex expression than the slope.
* Look into whether we can efficiently iterate over an altrep without expanding
  it.  Update: We can by partially expanding it using the stuff from iter.h,
  e.g. iterate by region which would generate and expand small chunks.  For now
  we're not going to bother with this.
* Decide whether partial should default to TRUE or FALSE.
* Zero width windows with "[]" bounds.
* Ensure partial condition is good on the new implementation (in particular,
  still feels weird that it doesn't matter what the bounds types are).
* Use `REAL_RO` for `x`, `at`, `left`, `right`?  Performance should be fine?
  But there is no way that a sequence can give a useful pointer without
  expanding.  Would have to use `ITERATE_BY_REGION` which AFAICT generates
  smaller vectors to iterate through so the whole thing doesn't have to be
  generated.
    * No, this is way to complicated to embed in the existing loop.
* Should start/end really do a hard subset?  Starting to feel that's wrong.
    * No, we won't have them to do a hard subset.  We could add an e.g. `hard`
      parameter but the use case for it seems tenuous.
* Be sure to test a window that is wider than the data to see that partial
  windows are computed correctly on both sides?  Should be okay.
* `DYNLOAD` warnings around `run()`; maybe that function doesn't need to be of
  the type DYNLOAD?  We know what the interface of it is, so we just need to
  check whether that's compatible with R's compilation mechanism.
    * Turns out R-devel was in a weird state where their own transition from
      empty arglist was incomplete.
* We should be able to specify align values that exceed the window range.
* Tests groups that aren't just 1:n or 0:n (I think we do this)?
* Test on windows.  Instructions for windows users about toolchain, etc?
* Fill out acknowledgments.
* Rename `mean0` to `mean1`
* Benchmarks:
  * Randomly ordered groups?
  * Larger group sizes?
* Try to interfere with r2c funs.  Need to document exactly what environment
  they are exposed to (base namespace).
* Pass data around in environments for better deparse (can't do this because the
  parameters might be unnamed via dots, or at least not easily, plus it only
  matters for the naked call).
* Add tests:
    * For parenthesis removal in mechanics.
    * For square tranform.
* When we dropped the use of env to match the arguments, how did keep track of
  the environment to look up functions in?  We don't, we just check function
  validity at run time.
* Emit warning/errors with the function call.
* Can we come up with a better error message for the matching of arguments?  Do
  we need our own matching instead of relying on `match.call`.
* Check dots with names (i.e. names that don't match formas but are caught by
  dots).  What should be done with these?  They probably should be unnamed.
* Check dots with multiple sets of dots, trying to e.g. pass both to group
  varying and flags/control params.
* Can we truly support dots (I think so, see dots section).
* Does arg order matching make sense?  We get: `function (y, x, ..., na.rm)` out
  of `r2cq(y - sum(x, na.rm = na.rm, ...), check = TRUE)`, dots get moved up,
  doesn't seem right.
* Are we checking that the functions resolve correctly at run time (and not just
  at compile time)? Yes, we check in `alloc`.
* Test that dots still work after we changed the eval environment; almost
  certainly won't so we have to think how to handle things that get matched to
  e.g. `..1`, etc.
* How can we efficiently warn of "longer object length is not a multiple" in
  vecrec?  We don't want a modulo for each group.  But we could check that the
  shorter object has not hit its length at the end of the loop and set a global
  variable?  Or use `flags` to communicate back?  When we compute each
  interaction size, we do (or could know) the group sizes, including possibly
  max and min group size.  But to be certain of a multiple you must be certain
  that there are no groups of odd sizes...  So I think it has to be done at run
  time, annoyingly.
* Do we need to handle the issue of `envir` for `match.call` at allocation time
  instead of at compile time?  Seems like the way this goes wrong is if the
  expression being looked at itself contains dots, e.g. literally `sum(...)`
  where the `...` need to be fetched.

    > (\(...) r2cq(sum(...)))(1, 2)
    Error in match.call(definition = definition, call = call, envir = envir,  : 
      ... used in a situation where it does not exist

Right now preprocess is just using `parent.frame()` for match.call, which
doesn't make any sense.

* Check assumption that double will hold `R_xlen_t`?  Or that length is no
  longer that the allowable size?  A bit tricky; no way to know what double size
  is.  This is because we return the group size to R; otherwise it would just be
  an R_xlen_t vector.  We need this to get the group max for the allocation.
  It's possible R guarantees this will be no bigger than e.g. 2^53 or some such.
  We added a check to assumptions.c.
* Ensure that all pointer parameters are allocated one extra element at end so
  that we can use the fun(++pointer) pattern without worrying about the last
  call overflowing (I think this might be allowed by the standard anyway,
  check).  Yes, allowed by C99 6.5.6 p8.
* Is it possible that set.seed could interfere badly with the random file name
  generation?  Yes, maybe try to initialize the pool
* Evaluation of non-compilable expressions in an env child of an env with
  appropriate symbols protected?  Such would be the symbols in the data, but
  what about the functions that are used?  That seems excessive.  No, we won't
  support this.
* Think though corner case of R_NA, NaN, Inf, etc: are we preserving semantics.
  Yes, mostly, but maybe not always (e.g. when we use `pow` instead of `square`)
* Look into GraalVM, Renjin?
* Only sort the columns that are used.  This is the case already as only things
  that match to the `r2c_fun` are submitable.
* Be sure to test situations where we have external data larger and smaller than
  group sizes.
* What do we do with NA groups?  Each it's own, or one big NA group?  One big NA
  group.  Single group; now documented.
* Document that we assume IEEE-754 (and thus existence of infinity and no
  overflow on conversion from long double to double), and check whether this is
  a reasonable assumption under C99 (probably no), or failing that under R.
* Figure out why external vectors are being duplicated.  Were seeing:

    Browse[2]> .Internal(inspect(alloc$alloc$dat[[5]]))
    @7fe16de86b68 14 REALSXP g0c0 [MARK,REF(65535)]  1 : 3 (compact)
    Browse[2]> .Internal(inspect(alloc$alloc$dat[[6]]))
    @7fe16de8b7b8 14 REALSXP g0c0 [MARK,REF(65535)]  1 : 3 (compact)

  for the slope calculation with y as 1:3 (literal).  Duh, is this just because
  we use `as.numeric`.

* Really need to figure out whether we want a formal interface to the functions.
  It could be auto-generated from all the unbound symbols like gsubfn does it.
* Annotate code with the call that it corresponds to



