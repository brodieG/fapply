# Reconcile

* Any symbols bound in branches used after that branch:
  * Reconcile: all.
  * Copy: those bound to non-local memory, and balance branches.
* Branch return value:
  * Reconcile: all, including if truly last.
  * Copy: those bound to non-local memory.
* Final value (when not branch):
  * Copy: if bound to external memory.

What do we do about:

    if(a) {
      x <- mean(x)    # 1 -> 4 -> 5
      y <- mean(y)    # 2      -> 5
    } else {
      x <- mean(z)    # 3 -> 4 -> 5
      y <- x          # 3 -> 4 -> 5
    }

We can't just rebind a symbol without copying because one branch might point to
the same memory, but another mightn't.  So each assignment, even when nesting, must
generate a copy always.

# Merging

Branch or final result never generate candidates, only assignments do.

We have:

* Original candidates.
* New candidates in each branch.
  * Add assignment in opposite branch to match the symbol.
* Promoted original candidates in each branch.
  * Remove candidate from alternate branch so it doesn't get double promoted?
    Shouldn't matter though.
* Overwritten candidates in each branch.
  * Should be okay?

Seems like locality cannot include nested branches?  So any symbol that is
re-assigned in a nested branch becomes non-local.  Also needs to be balanced.

    if(a) {
      x <- z
      if(b) {
        z <- x
        x <- y
        w <- mean(z)
        w + x
      } else {
        # x <- vcopy(x)  # is this needed?  YES!! RESIST TEMPTATION.
        mean(z)
      }
      x + w            # this should trigger
    } else {
      x <- mean(z)
    }

We need to be able to know if a symbol is branch local.  On branch exit, symbols
that are branch local and are either computed or will become computed by virtue
of `vcopy` can be considered global?  They can be if they are computed across
all branches being merged.  So, first we decide if a symbol use needs to be
`vcopy`'ed.  If it does, then we make it a candidate and it becomes branch
local / computed.  Subsequent uses of it should not trigger it, but once we exit
the branch, it should become global (b/c it will be if it is triggered).

So basically, on merge, anything that was local in the branch becomes global.

Is there such a thing as a non-computed local symbol for these purposes?
Probably not.

# Return Global Computed

    x <- mean(z); y <- mean(w); if(a) x else y

What about:

    > pp3c <- r2c:::preprocess(call3c, optimize = TRUE)
    > r2c:::clean_call(pp3c[["call.processed"]])
    {
        x <- y <- mean(x)
        if (a)
            r2c::rec(y <- x)
        else r2c::rec(r2c::vcopy(y))
    }

This happened when trying to fix:

    > r2c:::pp_clean(call3g3)
    {
        x <- if (a)
            r2c::rec(y <- mean(z))
        else numeric(0)
        x
    }

Problem is ultimately we don't want to vcopy `mean(z)` when `y` is unused, but
we do need to `vcopy(x)`.  The key is we need to add a

If symbol used:

    rec(vcopy(y <- rec(vcopy(x)))
    rec(vcopy(x <- rec(mean(x))))

If symbol unused:

    rec(vcopy(y <- x))
    rec(x <- mean(x))

So use the following:

* Actual `rec` on the outer call always.
* If computed expression:
  * Candidate `vcopy` on the outer call.
  * Candidate `rec` on the inner call.
* If non-local symbol:
  * Actual `vcopy` on the outer call.
  * Candidate `vcopy`/`rec` on the inner call.

We care about:

* Is it in branch.
* Is it branch result.
* Is it an assignment of a non-computed expression.
* Is it an assignment of a computed expression.
* Is it overall result.

    if (a)
      r2c::rec(r2c::vcopy(z))
    else
      r2c::rec(
        if (if (b) r2c::rec(r2c::vcopy(x)) else r2c::rec(r2c::vcopy(y)))
          r2c::rec(r2c::vcopy(w))
        else
          r2c::rec(r2c::vcopy(u))
      )


    {
        y <- mean(w)
        if (a)
            r2c::rec(r2c::vcopy(z))
        else r2c::rec(
          if (b)
            r2c::rec(
              if (c) r2c::rec(r2c::vcopy(x))
              else r2c::rec(r2c::vcopy(y))
            )
          else r2c::rec(r2c::vcopy(u))
        )
    }

Again running into the issue that we need to distinguish between a local symbol
that is a candidate and a local symbol that is computed.

    if (a) r2c::rec(r2c::vcopy(z)) 
    else {
      if (
        if (b) r2c::rec(r2c::vcopy(x))
        else r2c::rec(r2c::vcopy(y))
      )
        r2c::rec(r2c::vcopy(w))
      else r2c::rec(r2c::vcopy(u))
    }

# Symbol Tracking

For each assigned symbol/instance, we need to track when it's cleared vs used to
e.g. determine whether it is used outside of ifelse.  For ifelse purposes, we
can just record name/index of things that are used after ifelse.  To do this, we
create candidates, and promote them on use recording the use index.  We then
keep the latest use index for each symbol/creation index.

Each linearized call entry can track its tree index too?

How do we know the variable was used outside of current if/else though?  In the
other preproc we know because we track the local symbols.

    if(a) {
      x <- z
      y <- x
      z <- mean(y)
    }
    x + y
    y


# Constraint Overview

The over riding constraint is that every symbol must resolve to an unambiguous
size.  `if` and `for` control structures can create ambiguity in sizes (e.g.
different sizes in branches of if, different sizes within the loop / loop can
act like a branch if not taken).

Disallow cases where a variable might not be created that is later used:

* for:
  * Zero iterations (maybe).
  * `break` / `continue`
* if:
  * Brand new symbol.
  * Not all branches contain it.
  * What if the symbol exists from elsewhere?

Additionally:

* for:
  * variables read and written from must be consistent size before and
    after loop
  * variables must remain constant size in the loop (e.g. cannot grow)
  * variables written to in loop must be either unchanged in size, or the loop
    must be guaranteed to have at least one iteration.
* if:
  * variables written to must be the same size across all branches; branches
    that don't write ok so long as prior var same size.

Need to think about what compatible allocations are.  Certainly different
branches must produce the same size result.  Does the result need to end up in
the same allocation id?

# Dead Code Removal

1. Remove all non-last statements that are neither bound to symbols nor are last
   in a braces call.
2. Remove all unused bindings leaving the RHS around (self-assignments corner
   case).
3. Repeat until no changes?

For implementation, start at end(s) (plural for cases where we end in branches)?

(`{x <- y <- z; x}` is interesting - how do we resolve it - this was an earlier
question).

What to do about braces that don't have their return value used (just
assignments).  Should be able to keep trimming from end until first assignment.

# C Implementation / Allocation

Probably the way a loop would work is:

```
for(i in 1:10) {
  mean(x + i)
}
```

```
void run(
  double ** data, R_xlen_t * lens, int ** di, int * narg, int * flag, SEXP ctrl
) {
  (void) narg; // unused
  (void) ctrl; // unused

  dibase = *di;
  flagbase= *flag;
  for(i = 0; i < n; ++i) {
    // - Loop Overhead ---------------------------------------------------------

    // Reset baseline position for everythign that gets tracked.
    di = dibase;
    flag = flagbase;

    // Do something to update the value of `i` in the data
    update_loop_var(data, lens, *di++, *flag);
    ++flag; // Why is flag here?

    // - Normal Code -----------------------------------------------------------
    // mean(x)
    mean(data, lens, *di++, *flag);
    ++flag;
  }
  // If there are no iterations at all, we need to skip ahead to what *di and
  // *flag would have been.
}
```

What about `if`? e.g.:

```
test <- mean(x)
if(test > .5) {
  y <- mean(x)
} else if (test < .25) {
  y <- sum(x)
} else {
  y <- sum(z)
}
```

```
void run(
  double ** data, R_xlen_t * lens, int ** di, int * narg, int * flag, SEXP ctrl
) {
  (void) narg; // unused
  (void) ctrl; // unused

  // mean(x)
  mean(data, lens, *di++, *flag);
  ++flag;

  // test <- mean(x) NO-OP
  // NO-OP: assign(data, lens, *di++);
  ++flag; ++di;

  // test > 0.5
  gt(data, lens, *di++);
  ++flag;

  if(r2c_if(data, lens, *di, *flag))
  {
    ++flag; ++di;
    // mean(x)
    mean(data, lens, *di++, *flag);
    ++flag;
    // y <- mean(x) NO-OP
    // NO-OP: assign(data, lens, *di++);
    ++flag; ++di;
  }
  else
  {
    flag+=3; di+=3;
    if(r2c_if(data, lens, *di, *flag))
    {
      ++flag; ++di;
      // sum(x)
      mean(data, lens, *di++, *flag);
      ++flag;
      // y <- sum(x) NO-OP
      // NO-OP: assign(data, lens, *di++);
      ++flag; ++di;
    }
    else
    {
      flag+=3; di+=3;
      if(r2c_if(data, lens, *di, *flag))
      {
        ++flag; ++di;
        // sum(z)
        mean(data, lens, *di++, *flag);
        ++flag;
        // y <- sum(z) NO-OP
        // NO-OP: assign(data, lens, *di++);
        ++flag; ++di;
      }
    }
  }
}
```

But we probably need to do something as follows to ensure the offsets are all
correct.

```
di_save = di;
flag_save = flag;
if(r2c_if(data, lens, *di, *flag))
{
  ++flag; ++di;
  // mean(x)
  mean(data, lens, *di++, *flag);
  ++flag;
  // y <- mean(x) NO-OP
  // NO-OP: assign(data, lens, *di++);
  ++flag; ++di;
}
else
{
  flag = flag_save + 3; di = di_save + 3;
  // sum(x)
  sum(data, lens, *di++, *flag);
  ++flag;
  // y <- sum(x) NO-OP
  // NO-OP: assign(data, lens, *di++);
  ++flag; ++di;
}
di = di_save + 5;
flag = flag_save + 5;
```

Must every `if` always emit an `else`?  There is the implicit `else`, so
probably better to do so since then naturally we have the reconciliation (for
allocations) of the "yes" branch vs an empty branch.

A bit tricky to think about where the result of the `if/else` should be stored.

```
// Input
if(X, A, if(Y, B, C)

// Becomes
X
A

Y
B
C

if(Y, B, C)

if(X, A, if(Y, B, C))
```

This is good, except that everything but the last statement might not run.  So
the code processor needs to add some special things?

```

__COND__
X
__YES__:1
A
__NO__:3
  __COND__
  Y
  __YES__:1
  B
  __NO__:1
  C

if(X, A, if(Y, B, C))
```

So maybe what we really need is the code linearization to produce:

```
X
list(
  A,
  list(
    Y,
    list(
      B,
      C
) ) )
```

Should `Y` be on a different level?  Probably.  This would signal the allocator
to fork itself at each level, and on exit of each fork evaluate the different
branches to ensure they have self consistent sets of live symbols.  For this to
work properly on exit need to reconcile all the allocations and make sure that
the same symbols point to the same allocations, and that they are the same size.
If they point to different allocations, how do we reconcile them?  We can't
necessarily just swap them as each allocation creates a potential chain of
re-uses (although we know that surviving symbols will still be using their
allocation).  We could require that assignments use a fresh allocation?  This is
hard to know ahead of time as the assignment first just evaluates it's
expression, and only after locks up the memory.  The problem is that in one
branch, an assignment might end up using an over-large allocation, and in
another a just right one.

A naive view is that we look at all the new allocations created by the two
branches, and generate a new set of allocations that will fit both.  Then we
remap all the allocations to the new set, ensuring that persistent symbols get
assigned the same allocation.  This should work?  Need to think through the
possibility that the order in which the allocations are used creates a problem,
but it seems that so long as every allocation has a corresponding new allocation
bigger than or equal to itself, it should work itself out?

# If code Generation

How does code generation fit in?  That happens before the allocation.  Probably
code generation needs to recognize functions that wrap their parameters.  We
need to track:

* Indentation level.
* Prelude before each argument (for if/else)
* Epilogue (just closing brace)

So prelude would be:

    flag_save = flag;
    di_save = di;
    if(r2c_if(data, lens, *di, *flag))
    {
      ++flag; ++di; // can't ++di in call?  I guess we could

And epilogue:

    }

With then another prelude:

    else
    {
      flag = flag_save + ?;
      di = di + ?;

And final epilogue:

    }
    flag = flag_save + ?;
    di = di + ?;

It does mean we subvert the entire logic of code generation as we have to do it
between arguments, not after all the arguments are processed as is normally the
case.  Currently we have a 1-1 correspondence with a call and a
`record_call_dat`.  Is it okay to break it?

Currently for each `record_call_dat` call, there is an element added to the
`x[['call']]` list, with allocation implications.  Also there is a pairwise
correspondence from those to what gets generated at the C level.  There is no
concept of enclosure at the code gen phase, so we could possibly add the
prelude, and maybe the epilogue, but it's non trivial?

So we need a different function specialized for `if` (and maybe loops) that
slots into to the `pp_internal` stack.  It will:

* Process parameter 1 (the test) as normal.
* Insert the `r2c_if` call with the code generation of the prelude.

So maybe:

```
if(a) {
  b
  c
} else {
  d
  e
}
```

Becomes:

```
// if_test can't quite be a no-op as those automatically get commented out
r2c_if_test(a)       // generate if(...), NO-OP-ish as it just accesses the value
r2c_if_true()        // generate prelude, NO-OP
{
  b
  c
}
r2c_if_true_end()    // generate epilogue, NO-OP
r2c_if_false()       // generate prelude, NO-OP
{
  d
  e
}
r2c_if_false_end()   // generate epilogue, NO-OP
```

Maybe better once we don't need to increment indices b/c we specify them
directly:


```
r2c_if_test(a)
{
  b
  c
}
r2c_else()    // NO-OP
{
  d
  e
}
r2c_endif()   // NO-OP
```

For the last two the problem is the code generation needs to override the
default and produce:

   }
   else
   {

And:

   }

An alternative might be:

```
if(a) b else c
```

Becomes:

```
r2c_if_test(a)
r2c_if(r2c_if_true(b), r2c_if_false(c))
```

Which expands to:

```
a
r2c_if_test(a)  // -> if(r2c_test(a)) {
b
r2c_if_true(b)  // -> } else {             NO-OP
c
r2c_if_false(c) // -> }                    NO-OP
r2c_if(r2c_if_true(b), r2c_if_false(c))
```

The main advantage of this is that it allows the `r2c_if` call to get all the
data related to it's arguments, including argument lengths, within the existing
structure.

Make sure to register all of these in `PASSIVE.SYM` (or should we change it to
be `ACTIVE.SYM` that requires registration?).

All of this needs to be done before we get into `pp_internal` like the other
pre-preprocessing steps.  But we don't really want to expose this stuff to the
user, right?  One possibility would be to add to `r2c:::clean_call` the ability
to re-collapse the above back into the original if/else call the way we handle
`...` names and other things.

If we do it this way, the dedicated logic that we need to add is something that
can track the positions of the offsets.

**Maybe instead of doing stuff like di++ we do `mean(.., di[n])`**

That would massively simplify all the loops and everything else too.  We just
need to be sure to count all the calls carefully.

* Process parameter 2 (the yes condition) as normal, with a new indent level
  specified.
  * We need to recover how many total calls were processed so we can generate
    the correct offsets for the no condition prologue.
* Insert the epilogue.
* Insert the `r2c_else` call with the code generation of the prelude.
* Process parameter 2 (the no condition) as normal, with a new indent level
  specified.
  * We need to recover how many total calls were processed so we can generate
    the correct offsets for the ...
* Insert the epilogue.

When we do this, in `x[['call']]` we store a list?  Not ideal for code
generation, though it would be useful for the allocation.

So we need a mechanism for dealing with the epilogue that doesn't naturally have
a corresponding call.  Maybe we also have `r2c_endif` and `r2c_endelse` as
no-ops?  Or some other class of call that doesn't even get a comment?  One key
thing with no-ops is that they still generate entries in the offset arrays.
Perhaps we change no-ops not to do that?  Or just leave it as is.  Let's start
with as is with special `if` and `loop` preprocessing.

Need to handle the possibility of returning a NULL, should it just be a zero
length value?  It's okay for `if` to return different length results so long as
they are not written to a variable (but code that does this is likely a little
weird).

# If Allocation

Each `if` and `else` is a special call with one argument, as opposed to one
`if/else` with three arguments (condition/yes/no).  The allocation forks at the
`if` and at the `else`, and once the `else` is complete the allocation is
reconciled, including the return value of the `if`.

Probably should check that there is always an `r2c_else` after an `if`.

Do we need an empty call for the epilogues?  Maybe.

If we hit `if_true`, then it gets complicated, because we won't hit it until
we've hit all the contents...

Basically, we need to split the linearized call list back into its branches,
which will be really annoying.  So we need to make two versions?  But the `i`
indices are baked in from the preproc when we generate the code.  We are still
free to do whatever with the allocation array, but it's not trivial to do things
self consistently.

Instead maybe we can just save a snapshot of the allocation data once we hit the
`if_true`.  It would go in a stack, and each time we hit an `if_false` call, it
would unwind the stack and compare the two allocation structures to make sure
they are compatible with each other:

* Compatibility is just that the symbols with lifetimes exceeding the if/else
  are equal size.
* Make sure they point to the same memory.  This may require shuffling things
  around.
* More specifically, we're looking to make sure that:
    * Every unexpired symbol in the names array points to the same memory
      location and has the same allocated size.
    * If locations are not the same (but both exist), we need to reconcile
      locations.
    * Any mismatch in existence is an error.
    * Any mismatch in size is an error.

I think we just need to keep the names array.

Can we encourage the allocator to re-use the same memory for the same symbol if
it fits?  Won't help with a symbol getting written to multiple times at
different sizes (this is not disallowed, just we cannot guarantee the same
memory will be used).  Additionally, this is non-trivial because when memory if
first assigned, it is at the computation step, which is nested inside the
assignment and can't easily know it's result will have a symbol bound to it.

Problem is we cannot just move things to a free slot because the slot might not
have been free at the time the symbol was written to.  So do we just allocate a
new vector for every symbol written to in either loop?  Likely we do this for
any symbols that end up at different addresses.

Once we "move" the symbols, we need to go back and fix any references to the
symbols in question in the "ids" field of the `call.dat` elements?  But imagine
some symbol got written to free slot 5, how do we know that in any given
`call.dat` element the 5 referenced our symbol, vs something else that
temporarily occupied the slot?  For each name, we need to know what step it was
assigned on, so we can work back and update all the references up to that point.

We probably can't take advantage of e.g. the else branch using a particular slot
with the hopes we can declare that the earlier `if` branch must be able to use
that too.

One big problem in:

    if(1) x <- y
    x

Where `x` could be part of data or external.  We can reconcile, but we can't
write to the data.  This means for this to work we need to duplicate `x`.
Basically all symbols that are written to in `if` must be in the current scope,
or must be copied into the current scope.  I.e. we need equivalent of:

    x <- z
    if(1) x <- y
    x

Although this is okay too:

    if(1) x <- y
    else x <- z
    x

Assuming of course that `y` and `z` are themselves from the current scope.  And
if they are not?  We need to `vcopy` each of them to a new common location so
that `x` can satisfy the requirement.  Other cases to think about:

    if(1) x <- {y}
    else x <- z
    x

How do we fix this up?  Really challenging because we need this to happen in the
`preprocess` step.  Also creates the potential from inefficiencies since now we
guarantee that we have to copy `y` and `z` when in reality we only need one or
the other?

From a `preprocess` perspective this is probably okay because we know (or can
known what all the foreign symbols are).  So if we see that foreign objects are
referenced in an `if/else` or control, we add a `vcopy` for them, preferably in
the branches (what about empty else? Just make it non-empty with the vcopy,
loops will either need to do it before the loop (and possibly again in the loop)
or have a loop-else branch - probably need to be before if there is the
possibility of a break/continue).  The `vcopy` is only necessary if the symbol
is just re-assigned.  As soon as it's computed on we don't care anymore.

So we're looking for the special case where external symbols are transitively
referenced via repeated assignment, and more specifically, where the
re-assignment happens in `if/else` and differently across the branches, and the
symbol is used later.

As a shortcut, can we just vcopy all external symbols used in branches as part
of an assignment?

How does this work with scope and potentially nested functions?  `preprocess`
does not currently have a concept of scope (but alloc does).

What about:

    x <- mean(a)
    y <- mean(b)
    if(x > .5) u <- x else u <- y

Same problem.  Only time we avoid this problem is if the source of the
allocation is inside the `if/else` on both sides.

    x <- mean(a)
    if(x > .5) u <- x
    else {
      y <- mean(b)
      u <- y + x
    }

Here this is still a problem as we can't have `mean(a)` and `mean(b)` occupy the
same memory.

To recap, any assignment from a symbol external to the `if/else` to a symbol
that survives the `if/else` must include a `vcopy`.

    x <- mean(a)
    if(x > .5) u <- vcopy(x)   # add vcopy here
    else {
      y <- mean(b)
      u <- y + x               # don't need vcopy here
    }

So an extension of the `copy_last` business:

* Find all surviving symbols
* Of those, do any of them correspond to an alloc from outside the `if/else`?
* Add a `vcopy` to the point that they get assigned.

Simpler:

* Are we in if/else?
* If yes is there a sym <- sym assignment?
* If yes was the symbol defined in the current `ifelse`?
* If no, add a vcopy.
* What if it was defined in a nested `ifelse`?  That's probably okay.

So track all symbol assignments in the current `ifelse`.  Each nested `ifelse`
gets its own tracking.

# Merge `copy_oos` and `copy_last`

OOS(S) -> Out of Scope (Symbol)

In theory, if we get rid of redundant code, and we copy both first assignment to
in-scope symbol as well as return of out of scope symbol we should solve both
problems, and do so more elegantly than we currently are.

OOS assignment okay so long as it's not in an if/else block to a symbol that
survives the block.  So track if a symbol is out of scope.  If in an if block
and we try to copy it, then vcopy.  If not in an if block, then new symbol also
marked out of scope.  OOS symbols are those not part of the in-scope list.
In-scope are all assignments that happen in-scope.

If fall out of scope (e.g. exit `if/else`, end of function), then vcopy.  What
about nested functions?  Do they establish a scope for the purposes of this
stuff?  Maybe, even something like `force(x)` has to because we will consider
the return value to be in-scope?

So if we vcopy on first use by `<-` in a scope, or on first exit of a scope
where now scope is generally curly braces or `if` / `else` (do we force curly
braces everywhere they are optional for single statements)?  This might create
unnecessary copies, but if we then backtrack and eliminate dead code then the
copies won't happen.

So, curly braces establish a scope (this type of scope anyway)?  Well, not
really, only the function curly braces and control structure curly braces.  We
don't need to vcopy some random set of curly braces (but we don't allow random
sets of curly braces?).

    a <- mean(x)
    b <- { a }     // doesn't need vcopy
    b

vs

    b <- { a }
    b              // vcopy needed here

vs

    b <- a
    b              // vcopy needed here

vs

    a              // vcopy needed here

The most general version is we make a `vcopy` anytime an OOSS is used by a
passive function.  So what about the `{` in:

    a <- mean(x)
    b <- { a }     // doesn't need vcopy
    b

vs
    a <- mean(x)
    c <- mean(y)
    b <- if(e) a else c
    b

vs

    a <- mean(x)
    c <- mean(y)
    if(e) b <- a else b <- c
    y

These seem like different considerations.  In the first case we just need the
data bound to `a` to be somewhere that could be declared to be the result.  In
the others we need the data of either `a` or `c` to be explicitly copied to a
common location.

So maybe merging wholesale is not an option, but we still can probably use the
same code.

But back to first use of an OOSS by a passive function generates a vcopy.  What
makes a symbol an OOSS?  It is an external symbol, where external means from
data/args or from outside a control structure.

# Rebinding Symbols

Things like:

    x <- y <- z

Should be:

    x <- vcopy(y <- vcopy(z))

For any symbols that are written to and survive for re-use.  What about:

    x <- z      # does this need a `vcopy`?  No.
    x <- x + y

So it's not just OOS stuff, it's OOS that get's used by a passive function in a
disallowed context (return value, if branch).

For shared memory across symbols, the problem is one of them gets written to.

Maybe for branches missing the symbols we add:

    x <- vcopy(x)

And for branches that have them we could also just add them (error message might
be confusing when `x` doesn't exist).  Error message probably enough to not do
this.

So, for all symbols written to in `if/else`, first statement is to make `vcopy`
of them?  But what if the symbol is first created there?

That's probably cleanest.  The OOS business remains for the branches.  For
return values we can tell whether a symbol is "tmp" or not, so we only `vcopy`
it if it is not "tmp".

We need to address:

* OOS symbols returned.
* OOS symbols re-assigned in if/else (including indirectly via passive funs).
* Symbols with shared bindings (i.e. one or more other variables point to same
  memory) re-assigned in if/else (including indirectly via passive funs).

Eventually:

* Symbols with shared bindings before they are modified (e.g. with `[<-`).

This means we need to compute shared bindings in `preprocess`...  Also suggests
we want to get rid of dead code.

One challenge for both multi-bindings and OOS is we really want to eliminate
them where they are used.  This requires inserting a `vcopy` of the original
symbol right before they are used.  For branches that don't have the symbols
used in both branches this is problematic?

For branches, we have the following situations:

* Symbol pre-exists, or not.
* Assigned to in only one branch, or not.
* Symbol is problematic, or not (OOS or points to multi-bound memory).

* Source problematic
* Target problematic (for no assignment + exists case)

Variables:

* `source.external`
* `target.external`
* `target.missing`
* `assign.call`: whether part of assignment call chain (assign <- passive <- x)
* `assign.both`
* `in.if`
* `is.last`

```
source.external <- is.symbol(x) && !x %in% in.scope
if(source.external) {
  if(is.last) {
    x <- vcopy(x)
  } else if (assign.call && in.if) {
    # What if the symbol isn't used outside the `if`, but is used later
    # within the `if`?  Then dead code removal won't remove the vcopy.
    x <- vcopy(x)

    if(!assign.both) {
      # how do we know the assignment to this symbol happens in both branches?

    }
  }


|| (assign.call && in.if)) && source.external) {
  if(

}
```

We cannot re-use an existing allocation bound to our symbol no matter what
because of things like:
```
x <- mean(y)     # 3 -> 4
if(a) {
  y <- x         # 4 -> 4
} else {
  x <- mean(x)   # 4 -> 5
  z <- mean(y)   # 3 -> 4
  y <- x         # 5 -> 5  cannot become 5 -> 4
}

Should:

    x <- y
    if(a) x <- y

Become:

    x <- y
    if(a) x <- y
    else x <- vcopy(x)

Or:

    x <- vcopy(y)
    if(a) x <- vcopy(y)

Need to know all surviving symbols written in each branch.  Opposite branch will
gain `x <- vcopy(x)` at beginning for missing symbols, but if `x` doesn't exist
there will be an error.


There might be special cases where we can get away with it, but it's a lot of
work to figure them out.

So how do we track all the symbols that are assigned in each branch and survive?
Every time a symbol is assigned to it is killed, every time it is used it is
resurrected.  But to track this properly you essentially have to either re-do
the search as of each point in the stack, or rename all the symbols so that an
assignment cannot re-use an existing name.  But in this version of the rename we
don't need to do special renaming for if/else (in fact don't want to as
otherwise we wouldn't know about survival, except if we do dead code removal).

This is all to avoid extraneous `vcopy`.  If we allow extraneous `vcopy` then it
is simpler since then we don't have to identify surviving symbols.

Really difficult to track surviving symbols because of overwrites, possibly even
overwrites in branches.  If we ignore overwrites, then it becomes easier at the
cost of false positives, but we still need a mechanism for tracking position of
each call before we linearize the calls.  Can we process the tree backwards?  If
we do that we'll know perfectly that a symbol has been re-used after the `if`
call (a bit tricky to track intermediate `if` branches that only assign in one
branch).

So maybe backwards pass applying `vcopy2`, and forward pass either removing such
`vcopy2` or renaming them to `vcopy` if the symbol is a foreign reference?  What
about requiring that every symbol must exist in both branches?  The second
forward pass could check for this.

Once we have the `vcopy` in place, we're guaranteed that every symbol forwarded
in a special context (`if/else`, return) will point to a temporary allocation
that we can update at the allocation step.

Some temporary assignments not used outside of if/else but technically survive
because they are not deleted?

```
if(assignment && source.is.symbol) {
  if(target.exists) {
    if(source.problematic) {
      source <- vcopy(source)  # in both branches
      if(!assignment.both) {
        target <- vcopy(target)  # in both branches
      }
    } else if (!assignment.both) {

    }
  } else {
    if(source.problematic) {
      if(assignment.both) {
        # add `vcopy(source)` in both
      } else {
        # add self assign vcopy in branch missing it (source <- vcopy(source))
      }
    } else {
      if(assignment.both) {
      } else {
      }
    }
  }
}
```

* symbol pre-exists gets assigned in both branches
* symbol pre-exists gets assigned in one branch
  *

  / doesn't
* symbol gets assigned in both branches
* symbol gets assigned in only one branch



* existing symbol assigned in both branches
* existing symbol assigned in both branches

# Track Symbol Usage

## Correct Way To Track Symbol Usage

If symbol:
  If binding context or return context:
    If symbol exists in current branch context:
      All set.
    Else:
      *VCOPY* and add to beginning of current context, this will need to be done
      when we get to context-establishing call.  All future uses (even in
      different branches of same context) will benefit from this.  So each
      processed call returns a vector of symbols they need added.  It's okay for
      multiple calls to have overlapping symbols.  If a later call redefines a
      symbol, that's okay too.  We just need to track the defined symbols we had
      at the beginning.  When we exit the context we still return our set of
      defined symbols.  We do need to make sure that the set of newly defined
      symbols exists in both branches.
    Additionally, after assignment add symbol to current context.
    Else If "r2c_if" context:
      Recurse on both branches.
      Compare return symbol list and add missing symbols to each branch.
  Else If call context:


In forward pass, for each symbol, track what context level it is bound in.  For
each symbol use, check if it is a rebinding or return.

## General

We want to modify a call based on how a symbol was used / not used.  We could
parse calls backwards (reverse argument order) and find dead code.  Dead code is
code that isn't used in another call, which includes:

* Anything not referenced in the last element of `{`.

Tricky things like:

    x <- mean(y)  // should be dumpable
    x <- mean(z)

Rename would deal with these?  Yes, but that is currently buried in
`reuse_calls`.  Could split it out and do several things.  Assume it would
handle control structures correctly (break/continue?).

## Multiple References To Same Memory

Caused by:

    x <- passive(y)

E.g.:

    x <- y
    x <- +y
    x <- {y}

But then there are things like:

    x <- y
    y <- mean(w)



# Loop in relation to if

Same concept of prelude/epilogue.  Same concept of an empty else branch to
handle the allocation.  Main difference is going to be that the prelude needs to
update the `i` variable somehow, and reset all the offsets.

Also, unlike in `if` where we evaluate the condition as a stand-alone statement,
we probably don't want to do that with a `for` loop (what about a while loop?).
The "probably don't want" to is in consideration of the possibility of a smarter
way of generating the sequence (or maybe we start looking into altrep?).

Separately, does it matter if there are break/continues in the loop?  I guess we
disallowed them for expression re-use?

# Interesting Example

Pretty challenging dealing with loops.

```
x <- integer()
for(i in 1:10) {
  x <- c(x, i)
}
```

Each loop iteration is going to have a different size for x. The best we can
hope for is consistent size every iteration including the first.  This should
handle the case where the loop doesn't even run.

What about variables created in loops that are not taken?

# Loop implementation

Loop variables can be created in a child frame to the data.

Each loop body will generate a `run` statement, e.g.:

```
run(...) {

}
run_loop_1(...) {
  for(intmax_t i = 0; i < len; ++i) {
    run(...);
  }
}
run_loop_0(...) {
  for(intmax_t i = 0; i < len; ++i) {
    statement_0(...);
    statement_1(...);
    run_loop_1(...);
  }
}
```

Probably want two types of loops, loops where we know the start and end as
constants or other derivable data (`seq_along`), and others where we have an
unknown vector?  Might not be able to allow the second type, because at that
point we can't know how large a vector that is assigned to with e.g. `x[i] <- y`
will get.

```
for(i in seq_along(x))
  y[i] <- x[i] + 1
```

Is the latter:

```
for(i in x)
  y[i] <- z[i] + 1
```

At the allocation stage we need to determine the size of `y`.  It's fine if
we're just referring to an external symbol (or even a group symbol) as we can
check the content sizes.  But things like:

```
for(i in rev(x))
```

Get messier.  Likely we just allow symbols, or `seq_along`, or constant
expressions like `a:b` where `a` and `b` are known at allocation time (changing
them inside loop is fine since):

> The seq in a for loop is evaluated at the start of the loop; changing it
> subsequently does not affect the loop.

But they can't be computed within the `r2c` code.

