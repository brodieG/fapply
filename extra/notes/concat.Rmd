# Concat

Implementing `c` for doubles.  Main thing is a new side type which should
probably be "argsum"

Do we support `recursive` and `use.names`?

What do we do about names?  Our inputs are supposed to be unnamed, but do some
support named?  It would also be really nice to be able to use names for the
scalar case:

    c(a=1, b=2)

But not the case where inputs are named vectors?  Probably start without names
at all?  One issue is e.g. `quantile` that does generate names.

In order to track size, we need something like `ng + k`.  We can actually
leverage our existing `size` and `group` fields for this?  Not quite because
currently `size` is min size.  So we need `size.min`, `size.const`, and
`groups`.  Then it's reasonably straightforward.

How do we prevent a growing concat.  In a loop, we cannot have an input that was
previously generated from a concat?  No, that's too strict, this is okay:

    for() {
      a <- c(1, 2)
      b <- c(a, 3)
    }
    for() {
      a <- c(1, 2)
      for() {
        b <- c(a, 3)
      }
    }

But this is not:

    for() {
      a <- c(b, 2)
      b <- c(a, 3)
    }
    for() {
      a <- c(b, 2)
      for() {
        b <- c(a, 3)
      }
    }

There cannot be an input itself generated by a concat with any inputs that can
be traced back to yourself.  Ultimately the size of a variable can't change
across iterations.  So if we size everything in the loop twice and compare
sizes, maybe that tells us?  Do branches get in the way? Shouldn't because of
the equal size requirement.

Seems like for each concat in a branch, we need to track all the source symbols,
assigned in that branch.  So for `a` above we have `b`, and vice versa.

This is a preprocess thing.  Do we do it in `copy_branchdat`?  One benefit of
that is we keep track of the symbols being assigned to (need to check if that is
broken by `r2c_if`, I think it is).

So at any given for level:

* Find the symbols assigned to from a `c` at that level and any children, and
  map them to the symbols inside the `c`.
* On loop exit, check there is no interaction between any of the assigned to and
  assigned from symbols.

What about weird things like:

    for() {
      a <- c(b, 1)
      b <- for() {
        d <- c(a, 1)
        d
      }
    }

We need to keep track of the contents of the concatenation until we hit a real
boundary that does not carry through.

It does seem like `copy_branchdat` is the likely place to do this?

Maybe we need to implement `for` and `[` first.




