# To Do / Questions

## Vetr

* What about the case where you want to reference another argument in a vetting
  expression?  That gets interpreted as a template because the other parameter
  name is not `.`.
* Do we need to document that the `&&` and `||` tokens are lazy?

## Things to test

* That it is impossible to try to use an allocation before it would be created
  in the code.  Tricky with loops.
* Loops with no iterations.
* `if` without `else`:
  * Also cases where all `if` written symbols pre-exist, and where some don't.

* Unary plus:
  * Executes vcopy correctly when needed
  * Coerces logical to integer

## Current

* New return value cases to handle in branches:
  * If it is a local binding from a computation, do we need to vcopy?  Maybe
    not?  No, we don't need to copy it.  The problem is when the binding is
    non-local.  So we make a candidate on that binding.  If that binding is
    used, then it will be vcopied.  Otherwise we can just use it directly as the
    return value.
  * If it is a non-local biding it needs to be copied if the return value is
    used (last part could potentially be handled by dead code removal).
  * It is a computing expression.
    * Nothing, we can reconcile directly.
  * A binding expression?
    * Same as a local binding, but for the whole expression.  So we add
      candidates for the entire `assign.to` in the binding chain?  Basically,
      same behavior as normal, except that we require candidacy even when the
      thing being bound is a computing expression.  So we need a modification on
      the `last` flag which is when the expression is returned.
  * A passive expression, presumably depends on what it contains.

  * It is a maybe non-local binding, an assignment expression, or a passive
    expression returning .
    * If `if` inside a computing call, assignment, or if it is returned, vcopy
      it (possibly again).
  * It is a binding expression.
    * `vcopy` the whole thing.
  * It is a passive expression.

* Do we allow if's nested inside arguments (probably yes)?  If we do, what
  happens to assignments within the if branches (probably disallow these)?

* Modifiers:
  * `if` is last expression vs not.
  * Return value is used or not.


* Formal detection incorrect for `r2cq({if(a) x <- y else x <- z; x})` as `x` is
  included in the formals.

* Defer creation of temporary vectors until end (just record their size) so that
  we don't allocate vectors we don't use.  We should also identify unused
  vectors and not allocate them (e.g. because branch reconciliation made a
  vector unused - does this actually happen)?

* Need to figure out how to handle the assignment to the result slot now that
  there could be multiple calls writing to it due to branches.  It seems like we
  need to switch this to be an ex-post step where we identify the last
  computation.  The challenge is if the last computation is also an assignment.
  Maybe we don't allow assignments as the last step?  That would simplify code
  somewhat?  Maybe it doesn't matter since assignments just forward their
  allocation.  So we let the process run, then, at the very end, get the final
  memory slot used, and go back and update all instances of that in the call
  data?

* is `r2c_if` really passive?

* Do `for` and `while` need to be decomposed?  Probably.

* Try to simplify `copy_symdat` by removing unused bindings.  Then being used
  out of context can be simplified to being return value of braces or a being
  used outside of context?  See dead code removal in control notes.
* Dead code optimization.

* Check that user doesn't introduce their own `vcopy`'s.

* Implement `r2c::ccopy` to copy constants into vectors.

* Move the disallowed assignment error to somewhere that does not use the
  renamed expression as that is then incomprehensible.

* Test error handling around missing symbols that are `vcopy`ed.  In particular
  whether error messages around them when they are part of the iteration data vs
  external makes sense.

* At what point in preprocess can we start assuming valid calls (assignments
  with 3-4 parameters, only known funs, etc.).  Matters for the OOS stuff.

* Make sure branches work well with multiple symbol assigned to same slot (`x <-
  y <- z`).

* Double check that the re-use optimization doesn't attempt to re-use an
  expression computed only in one branch.  Or maybe if there are two if/else's,
  each with the expression in one branch, how does it treat that?

* Are we appropriately checking that we don't assign to a symbol that is then
  used as the function name in a call?

* `code_gen_*` functions should be in a list instead of floating around as
  objects.  This would ensure we don't accidentally use the wrong code gen as we
  can select it by name.

* Switch `PASSIVE.SYM` to be `!x %in% ACTIVE.SYM` to reduce the odds of
  accidentally forgetting to designate.  Since we must implement a handling of
  the passive symbols, it is a lot harder to accidentally forget to include
  something in `ACTIVE.SYM`.

* Should we move `transform_ifelse` earlier to have it automatically generate
  the `r2c::vcopy` for the `else` branch when it is missing?  In general it
  seems dangerous to allow the possibility of `copy_last` not being run.

* `call_valid` should have an option to check that a call has been matched to
  avoid problems where we introduce a new call via manipulation and it isn't
  matched.  But `call_valid` is used in the matching step too.

* Implement "eqlen" r2c token type (for e.g. `r2c_if`).

* Remove unnecessary braces in for `get_r_code` (e.g. those generated by `if`
  replacement).

* Prevent users from using `r2c::if_test` and related functions directly.  They
  may only appear in a very specific order.  How do we disallow them?

* Think carefully through case where the `else` branch doesn't exist but we code
  it as returning an empty numeric vector.  This is a reasonably approximation
  of returning a NULL.

* Undo the `if/else` conversion for display in `get_r_code`.

* Are `A && B` and `A || B` actually lazy?  Probably not given the linearization
  that evaluates each argument before the result?  We could consider translating
  the above into `if(A) B else FALSE` and `if(A) TRUE else B` once `if` is
  implemented (need to think about preserve logical for these cases).

* Change default for `show_c_code` to be `all`.

* Cleanup `code_gen_x`.  A lot of things should be parametrized so that we're
  consistent across `code_gen` functions.

* Explore `fma` (floating multiply add).

* Should we be using `islessgreater` and similar?  Probably since the R NaN is
  not quiet by default.

* If we implement unary `+` as a noop, do we do it at the function level, or at
  the "parsing" level?  If we do it at the function level we need to check
  carefully that the addition of a noop beyond braces and assignments doesn't
  mess things up.

* Be more aggressive about specifying lengths in args.reg (e.g. binops don't
  right now)?

* Make sure braces are only nested in braces (except for the special case of the
  `if/else` / `loop` functions).  This is to prevent people bypassing the
  prohibition against assigning within arguments by throwing a brace expression
  in an argument.

* ISNAN vs isnan? (R_ext/Arith.h).  Return R NAN not just NAN?  For logicals
  doesn't matter as much if they get coerced eventually to NA_LOGICAL, but if we
  add a no-lines mode then it might matter.

* What do we do about repeated external symbols getting added to the allocation
  table?  We need to deal with it because for non-numeric the coercion to
  numeric will force a full copy every time.  See notes "External Symbols".
* Reconcile binding of group names and assignment names?  A bit awkward now in
  `append_dat`.  What about `MoreArgs` names (these are treated as external
  symbols, stored in an env ahead of the parent env)?

* Do we offer a no-lies mode where we don't coerce results back to
  integer/logical?  Yes, should be easy to implement, we just need a parameter
  name that makes sense.

* Add warning for any/all coercion of doubles?

* Can we improve the stand-alone execution so it doesn't suffer the penalty of
  generating the useless group vector?  We should be able to do it through
  `process_groups`, i.e. generating its output, especially if the sorted version
  does not include the order vector.

## Next

### Generic

* Improve the ability to provide what group had a bad length `&&` error, and
  possibly the flexibility to warn based on value of
  `_R_CHECK_LENGTH_1_LOGIC2_`.

* Make sure we don't directly capture "r2c_fun" functions from `_pre/data.R` in
  tests as they will capture `_pre/data.R` values.
* Think through the implications of using the lexical env for "r2c_fun"
  functions with respect to the future `r2c` function library (see notes "Eval
  Env") .

* In the allocation data, is it the case that `group` and `is.na(size)` are the
  same?  Maybe, but we need to think ahead to cases where we'll have sizes that
  will be e.g. `n * g + k` where `g` is group size (to allow `c`).
* Will be complicated to think how to convey complex sizes like the ones
  generated by `c` would be.

* Look into the standalone R math library.

* Consider whether `x^2` -> `x * x` should be an optimization (especially given
  that `x` could be a complex expression (actual, this special case is handled
  with `square` which avoids the repetition).
* Now that we have `reuse_calls`, do we want to use `x * x` instead of `square`?
* Transformations probably should not be considered optimizations, because e.g.
  for `square` not applying it leads to non-identical results.

* Make sure vecrec works with `...`, e.g. as would be needed for `paste(...)`
  (although maybe that's not the best example given 0-len behavior).  Test would
  be to implement `pmax`.

* For `if` and similar, how do we rationalize the same symbols being assigned to
  in different branches?  We need to ensure they are the same size, but also
  that they both use the same memory slot.
* Handle assignment to function symbols, etc?  There shouldn't be confusion with
  invocation, but if we ever implement `lapply`, etc?

* Add post-processing of function result (e.g. to attach names, etc, as in
  `quantile`).

* Rename depth to height.  No, rename depth to level.  The use of height and
  depth with an upside down tree is ridiculous and not my fault.

### Optim

* Can we mark some functions as okay to re-use memory, where the result can be
  one of the inputs?

* Profile a compilation call and track (maybe it doesn't matter because really
  it's all about that first compilation to load the tool chain).

* Can we get more memory efficient by e.g. using `+=`.  This is complicated, see
  notes "Memory Re-Use".

* Can we avoid `r2c_copy` in cases where we know the symbol is assigned to from
  an expression?  The big challenge is dealing with e.g. `if` and all the
  constraints that adds.

* Identify unused assignments as a courtesy warning?  This could be extended to
  unused expressions, which could potentially be eliminated (possibly
  iteratively for e.g. `x <- y; z <- x` where then `z` is unused).

### Features

* `reuse_call` needs to track what the original call was so we can provide
  better error messages if something goes wrong at some point.

* Semi-internal error should issue conditions that can be caught by the
  compilers or runners to return as errors with a meaningful calling function
  instead of an internal function.

* Should we have safety tests in the code to be controlled by a debug mode flag?

## Memory Re-Use

## Zero Len

## For CRAN

* Include README/extra contents in vignettes
* Figure out why winbuilder doesn't work.
* Errors in `match.call` that show the deparsed argument might deparse
  differently on different systems (`group_sum` error tests).
* Add iterator breaks?

## Other

* Make sure there are interrupts.  Can we use "R_ext/Intermacros.h".  It seems
  yes generally, but they are not explicitly part of the API, and then there is
  the question of whether it makes sense to do so, or if we should just be doing
  this at the group level?
* share `lcurry` with klutometis
  https://github.com/klutometis/R-functional/issues
* Make overflow testable.
* Group label generation should potentially return position of vector rather
  than actual label to allow flexible re-use of labels beyond just factors (i.e.
  we subset the input vector to generate the labels).
* Special case of constant result lengths could be an optimization for group
  where we don't have to generate the vector, although there should always be
  few groups relative to vector elements, so complexity not worth it?
* Migrate to tapply structure.  More generally, explain interface?
* Allow more then `INT_MAX` groups (labels are limiting right now)?
* What if compilation fails, do we have good error messages?
* Don't use double for group sizes unless we have groups that are too large.
  **probably not worth it** b/c the group sizes result is only as big as the
  number of groups, so very small in the grand scheme of things.  First level is
  simply to check input vector size, and if less than `INT_MAX` use that, next
  step would be to switch from int to double if we do have a vector that exceeds
  the size limit (but then we need to test for that...).  Does that mean we need
  a limit to int?  Will be annoying to have logic for both.
* Should sorted be "assume.sorted"?  Probably.  Could add check that it is (see
  next).
* Process groups might be able to determine that things are sorted?  If things
  are always e.g. increasing, then it must be the case that they are sorted.
  Evaluate the overhead of this; should be low as it would just be done in the
  second pass that stores the sizes?  Something still needs to be declared as
  sorted though.  It's relatively cheap to check that it is, but not so cheap
  that we would always want to run that check.
* Perhaps we got too lazy with POW, do we need to handle all the other cases
  arith handles?  Maybe, but if we do we'll likely need our own `pow` function,
  as it stands right now we're likely to get non-identical results in the case
  of NA or Inf (or at least particular variations of them).
* Re-implement modulo.
* The `check=TRUE` might be better done with an explicit check function.
* For running function directly, can we pass data as an env so the traceback
  doesn't explode (but make sure this doesn't cause reference / refcount issues)?
* What is the implementation cost of allowing internal functions to advance the
  data pointers so they don't have to be manually moved after each function
  iteration?
* Implement sum64 and mean64 to use double accumulator (note we've tested that
  double accumulators are slower).
* We can no longer use `mean <- mean.default` and `r2c` at same time (this might
  be correct, but will make readme a bit more complicated).  Also, error message
  is very confusing in this case as `mean.default` is also from the base
  namespace, even though the masking is defined at the global level.
* Add destructors that will unload the shlib and delete file file when the
  corresponding object is garbage collected (finalizer).
* Add check to `r2c` funs that verify the `r2c` version, the R version, and the
  platform (anything else)?
* Figure out a better way to store the object than embedding it with `bquote` in
  the function (e.g. retrieve from the call like `rlang`, but not sure that's
  better).
* Think about `df %>% group_by(g) %>% filter(x > min(df$x)`.  This should
  resolve naturally if we allow `[['x']]` as "normal" expression.
* Can we optimize label generation for cases where the last step is constant
  size or size of groups?
* Better introspection tools for intermediate products so we can see what they
  are.
* Are names sufficient to disqualify from nakedness?  How do names behave in
  recycling?  Do we want to allow other attributes to persist?
* Make sure to have a function that uses the `ctrl` functionality to check that
  it works properly (once we switch to `flag` for most functions).
* Make sure pointer arrays are aligned.  Use `malloc`?  If so internal code
  cannot use `error`, and we can't guarantee that?  Can we register a finalizer
  somehow (probably will need to).
* Make sure headers go in in correct order; it may not work if we structure
  workflow around C functions?  Maybe okay if each group of functions does the
  right thing?  Do we need to include the headers before each group of
  functions?  Do we need to keep translation units independent (but the lose the
  benefit of static funs)?  This is almost certainly a real problem that needs
  to be addressed.
* Ensure all entry point names are unique and that there are no collisions.
  Maybe this can be done on registration?
* Special case where all groups are same size and there is an external vector of
  that size?
* Add capability to specify functions in non-standard ways (e.g. `base::sum`, or
  `(get("sum", as.environment("package:base"))`)?  Maybe not, that seems like
  potential trouble.  Certainly document also things like `f <- sum; f(x)`.
* Is it faster to compute complex expressions pairwise (i.e. full vector scan of
  two vectors), or do each row in full once?
* Look into using R_GetCCallable (see WRE) instead of what we're doing now.  It
  seems though that to do so we'll need to generate a full package which will
  further slow down the compilation.  What does `inline` do?
* Check name isn't used already.
* `?SHLIB` states some binary distributions don't include `R CMD SHLIB`.
* Figure out how to call the current version of R (e.g. `RD CMD SHLIB`).
* See how far back this works in terms of R versions.
* What happens when this stuff is serialized?
* Is there an alternative to R_FindSymbol?  Can we get it to be made part of the
  API.
* Can we use this in some way for e.g. really wide matrices where each column
  takes the place of an argument?  Generating a pointer for each column then may
  be less efficient.
* Lags and similar (i.e. `x[i] = x[i] * x[i - 1]`).
* Re-use repeated expressions.

